
# Problem 29

Problem 29 requires the use of `UNDEFINED`, which is some
instance of the type parameter. I don't know how to do that in
`rust`, so I decided to replace it with `Option`. However,
ravencheck doesn't know about `Option`. Therefore, I added the
following custom enum.

```rust
#[define]
#[derive(PartialEq, Clone)]
enum MyOpt<T> {
  Some(T),
  None
}
```

# Problem 14

Problem 14 is the same as problem 29, but with `Int`s replacing
`Nat`s. The following is how I implemented `Int`s.

```rust
#[define]
enum Int {
  P,
  N,
  S(Int)
}
```

My initial thought was to use `Z/S/P` for zero, successor-of,
and predecessor-of, but I decided that would introduce too many
ambiguous number representations. Instead, I opted for `P/N/S`
to represent positive zero, negative zero, and successor-of. We
will say a number is negative if it is rooted at negative zero:
For instance, 2 is `S(S(P))` while -2 is `S(S(N))`. This
introduces only one ambiguously represented number: Zero.
Therefore, we introduce the following axiom to make sure $\pm 0$
are equal.

```rust
#[assume]
fn plus_minus_zero_eq() -> bool {
  Int::P == Int::N
}
```

There are a few more operations which are used without
definition for integers. The following are rough approximations
of them which are equivalent for the purposes of this problem.

```rust
#[define]
fn is_positive(x: Int) -> bool {
  match x {
    S(previous) => match previous {
      P => true,
      N => false,
      _ => is_positive(previous)
    },
    _ => false
  }
}

// This only takes positives herein, but generally functions
// to reduce the magnitude by 1, with a fixed point at 0.
#[define]
fn previous(x: Int) -> Int {
  match x {
    S(p) => p,
    _ => x
  }
}

#[define]
fn is_zero(x: Int) -> bool {
  match x {
    P => true,
    N => true,
    _ => false
  }
}
```
