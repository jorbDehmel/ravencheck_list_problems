
# Decomposition attempt 3 (2/13/26)

Given

```rust
#[define]
#[recursive]
pub fn append<T: PartialEq>(x: LinkedList<T>, y: LinkedList<T>) -> LinkedList<T> {
  match x {
    LinkedList::<T>::Nil => y,
    LinkedList::<T>::Cons(z, xs) => LinkedList::<T>::Cons(z, Box::new(append::<T>(*xs, y)))
  }
}
```

WTS

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(xs: LinkedList<T>, ys: LinkedList<T>, zs: LinkedList<T>)]
fn injectivity_of_append<T>() -> bool {
  implies(
    append::<T>(xs, zs) == append::<T>(ys, zs),
    xs == ys
  )
}
```

We apply the definition of append.

```rust
implies(
  append(xs, zs) == append(ys, zs),
  xs == ys
)

// Becomes

implies(
  match xs {
    Nil => zs,
    Cons(xs_data, xs_next) =>
      Cons(xs_data, append(*xs_next, zs))
  } == match ys {
    Nil => zs,
    Cons(ys_data, ys_next) =>
      Cons(ys_data, append(*ys_next, zs))
  },
  xs == ys
)
```

We examine this in four cases.

## Case 1: `xs = ys = Nil`

The premise becomes `zs == zs`, which is true. The consequence
becomes `Nil == Nil`, which is also true. Therefore, this case
holds.

## Case 2: `xs = Nil, ys = Cons(t1, l1)`

The premise becomes `zs == Cons(t1, append(l1, zs))`. The
consequence becomes `Nil == Cons(t1, l1)`, which is false.
Therefore, we need to prove that the premise is also false.

Equivalently, given `zs, t1` and `l1`, WTS
`zs != Cons(t1, append(l1, zs))`. We will create a lemma to
show this.

### C2.L1

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>, l: LinkedList<T>)]
fn case_2_lemma_1<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(l, zs))
}
```

If we rewrite this as an assumption, it causes the overall case
to pass. Therefore, it is sufficient to prove this.

## Case 3: `xs = Cons(t1, l1), ys = Nil`

The premise becomes `Cons(t1, append(l1, zs)) == Nil`. The
consequence becomes `Cons(t1, l1) == Nil`, which is
false. By commutativity of equality,
`Cons(t1, append(l1, zs)) == Nil` iff
`Nil == Cons(t1, append(l1, zs))`. This was proved in the
previous step, so this case holds.

## Case 4: `xs = Cons(t1, l1), ys = Cons(t2, l2)`

The premise becomes
`Cons(t1, append(l1, zs)) == Cons(t2, append(l2, zs))`. The
consequence becomes `Cons(t1, l1) == Cons(t2, l2)`.

Assuming the premise, we know that `t1 == t2` and
`append(l1, zs) == append(l2, zs)`. By the inductive hypothesis,
we know that `append(l1, zs) == append(l2, zs)` implies
`l1 == l2`. Since `t1 == t2` and `l1 == l2`, the consequence is
true. This case holds.

# Proving lemmas

## L1

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>, l: LinkedList<T>)]
fn lemma_1<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(l, zs))
}
```

All cases verify except the one where neither `zs` nor `l` are
nil.

Assume neither are nil: `zs = Cons(t1, l1), l = Cons(t2, l2)`.
By the IH, we also know that `l1 != LinkedList::<T>::Cons(t1, append::<T>(l3, l1))`
and `l2 != LinkedList::<T>::Cons(t2, append::<T>(l4, l2))`.

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l1: LinkedList<T>, l2: LinkedList<T>)]
fn lemma_1_neither_nil<T>(t: T, t1: T, t2: T) -> bool {
  implies(
    l1 != LinkedList::<T>::Cons(t1, append::<T>(l3, l1)) &&
    l2 != LinkedList::<T>::Cons(t2, append::<T>(l4, l2)),
    // This is lemma 1 expanded under the
    // neither-nil case
    LinkedList::<T>::Cons(t1, l1) != LinkedList::<T>::Cons(
      t,
      append::<T>(
        LinkedList::<T>::Cons(t2, l2),
        LinkedList::<T>::Cons(t1, l1)
      )
    )
  )
}
```

However, somehow this is insufficient to imply lemma 1, even
with all the other cases?

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>, l: LinkedList<T>)]
fn lemma_1<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(l, zs))
}

// Case 1: Nil, nil
// This is proven
Nil != Cons(t, append(Nil, Nil))
true

// Case 2: Nil, cons
// This is proven
Nil != Cons(t, append(Cons(l_data, l_next), Nil))
true

// Case 3: Cons, nil
// Assuming this is insufficient to prove lemma 1
Cons(zs_data, zs_next) != Cons(t, append(Nil, Cons(zs_data, zs_next)))

Cons(zs_data, zs_next) != Cons(t, Cons(zs_data, zs_next))

???

// Case 4: Cons, cons
// Assuming this is insufficient to prove lemma 1
Cons(zs_data, zs_next) != Cons(t, append(Cons(l_data, l_next), Cons(zs_data, zs_next)))

???

// Assuming both cases 3 and 4 is insufficient to prove lemma 1
```

I am unsure how to proceed to prove lemma 1, since decomposing
it seems not to work. I could try introducing an auxiliary
function, perhaps one relating to lengths, then try to prove it
as a transitory implication.

Perhaps: `is_shorter_than(a, b) => a != b` and
`is_shorter_than(zs, Cons(t, append(l, zs)))` implies
`zs != Cons(t, append(l, zs))`

```rust
#[define]
#[recursive]
fn is_shorter_than<T>(a: LinkedList<T>, b: LinkedList<T>) -> bool {
  match a {
    LinkedList::<T>::Nil => match b {
      LinkedList::<T>::Nil => false,
      LinkedList::<T>::Cons(_b_data, _b_next) => true
    },
    LinkedList::<T>::Cons(_a_data, a_next) => match b {
      LinkedList::<T>::Nil => false,
      LinkedList::<T>::Cons(_b_data, b_next) =>
        is_shorter_than::<T>(*a_next, *b_next)
    }
  }
}

#[assume]
#[for_type(LinkedList<T> => <T>)]
fn is_shorter_than_implies_ne<T>(a: LinkedList<T>, b: LinkedList<T>) -> bool {
  implies(
    is_shorter_than(a, b),
    a != b
  )
}

#[assume]
#[for_type(LinkedList<T> => <T>)]
fn is_shorter_than_appendation(zs: LinkedList<T>, t: T, l: LinkedList<T>) -> bool {
  is_shorter_than(zs, Cons(t, append(l, zs)))
}
```

Somehow, this doesn't imply lemma 1 either.

At this point, I start writing out a series of statements which
should be true to check if any are not provable.

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>)]
fn lemma_1_1<T>(t: T) -> bool {
  LinkedList::<T>::Nil != LinkedList::<T>::Cons(t, append::<T>(l, LinkedList::<T>::Nil))
}

#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>)]
fn lemma_1_2<T>(t: T, t1: T) -> bool {
  LinkedList::<T>::Cons(t1, LinkedList::<T>::Nil) != LinkedList::<T>::Cons(t, append::<T>(l, LinkedList::<T>::Cons(t1, LinkedList::<T>::Nil)))
}

#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>)]
fn lemma_1_3<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(LinkedList::<T>::Nil, zs))
}

#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>)]
fn lemma_1_4<T>(t: T, t1: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(LinkedList::<T>::Cons(t1, LinkedList::<T>::Nil), zs))
}
```

The final example, `lemma_1_4`, fails to verify in case `Cons`.

```rust
Cons(t2, l2) != Cons(t, append(Cons(t1, Nil), Cons(t2, l2)))
```

This made me wonder: Does it know that `append(Cons(t, Nil), l) == Cons(t, l)`?

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>)]
fn append_single<T>(t: T) -> bool {
  append::<T>(
    LinkedList::<T>::Cons(t, LinkedList::<T>::Nil),
    l
  ) == LinkedList::<T>::Cons(t, l)
}
```

As it turns out, no (but asserting it doesn't fix any problems).
We'll still deal with it, because it's a problem.

```rust
append::<T>(
  LinkedList::<T>::Cons(t, LinkedList::<T>::Nil),
  Cons(t1, l1)
) == LinkedList::<T>::Cons(t, Cons(t1, l1))

// By def of append:
Cons(t, append(Nil, Cons(t1, l1))) == Cons(t, Cons(t1, l1))

// NEED TO PROVE THIS STEP

// By def of append:
Cons(t, Cons(t1, l1)) == Cons(t, Cons(t1, l1))

true
```

As annotated above, we need to add something for this to verify.

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>)]
fn append_to_nil<T>() -> bool {
  append::<T>(
    LinkedList::<T>::Nil,
    l
  ) == l
}

#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>)]
fn append_single<T>(t: T) -> bool {
  append::<T>(
    LinkedList::<T>::Cons(t, LinkedList::<T>::Nil),
    l
  ) == LinkedList::<T>::Cons(t, l)
}
```

Now this chunk, as well as `lemma_1_4`, verify. However,
`lemma_1` still does not. We will try another variation on an
instantiation of `lemma_1`.

## L2

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>, l1: LinkedList<T>)]
fn lemma_2<T>(t: T, t1: T) -> bool {
  LinkedList::<T>::Cons(t1, l1) != LinkedList::<T>::Cons(
    t,
    append::<T>(l, LinkedList::<T>::Cons(t1, l1))
  )
}
```

This fails to verify in case `Cons`.

```rust
// Case 1: Nil, nil
Cons(t1, Nil) != Cons(t, append::<T>(Nil, Cons(t1, Nil)))

Cons(t1, Nil) != Cons(t, Cons(t1, Nil))

Nil != Cons(t1, Nil)

true

// Case 2: Nil, cons
Cons(t1, Cons(t2, l2)) != Cons(t, append(Nil, Cons(t1, Cons(t2, l2))))

Cons(t1, Cons(t2, l2)) != Cons(t, Cons(t1, Cons(t2, l2)))

true

// Case 3: Cons, nil
Cons(t1, Nil) != Cons(t, append(Cons(t2, l2), Cons(t1, Nil)))

Strengthening

Nil != append(Cons(t2, l2), Cons(t1, Nil))

nil_nil_append

true

// Case 4: Cons, cons
Cons(t1, Cons(t2, l2)) != Cons(t, append(Cons(t3, l3), Cons(t1, Cons(t2, l2))))

Definition of inequality

t1 != t
or
Cons(t2, l2) != append(Cons(t3, l3), Cons(t1, Cons(t2, l2)))

Strengthened inequality

x != append(Cons(t3, l3), Cons(t1, x))

Relabelling

x != append(y, Cons(t1, x))

append_single_2

true
```

But we need to verify `append_single_2`

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l: LinkedList<T>, x: LinkedList<T>)]
fn append_single_2<T>(t: T) -> bool {
  x != append::<T>(l, LinkedList::<T>::Cons(t, x))
}
```

This fails to verify in case Cons.

```rust
// Case 1: Nil, nil
Nil != append(Nil, Cons(t, Nil))

Definition of append

Nil != Cons(t, Nil)

true

// Case 1: Nil, cons
Cons(t1, l1) != append(Nil, Cons(t, Cons(t1, l1)))

Definition of append

Cons(t1, l1) != Cons(t, Cons(t1, l1))

Relabelling

x != Cons(t, x)

l_ne_cons_l

true

// Case 1: Cons, nil
Nil != append(Cons(t1, l1), Cons(t, Nil))

Definition of append (Does it know this?)

Nil != Cons(t1, append(l1, Cons(t, Nil)))

true

// Case 1: Cons, cons
Cons(t1, l1) != append(Cons(t2, l2), Cons(t, Cons(t1, l1)))

Relabelling

x != append(y, Cons(t, x))

PROVE THIS PART

true
```

We'll break off `PROVE THIS PART` into lemma 3.

## L3

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(x: LinkedList<T>, y: LinkedList<T>)]
fn lemma_3<T>(t: T) -> bool {
  x != append::<T>(y, LinkedList::<T>::Cons(t, x))
}
```

This fails to verify in case Cons. Assuming it doesn't fix any
issues.


# Restart for lemma 1 (2/21/26)

Trash all the old lemmas except lemma 1.

WTS `lemma_1_cons`:

```rust
Cons(t1, zs_next)
!=
Cons(t, append(l, Cons(t1, zs_next)))

// Definition of append

Cons(t1, zs_next)
!=
Cons(t, match l {
  LinkedList::<T>::Nil => Cons(t1, zs_next),
  LinkedList::<T>::Cons(l_data, l_next) =>
    LinkedList::<T>::Cons(
      l_data,
      append(l_next, Cons(t1, zs_next))
    )
})

// Equality implication

zs_next != match l {
  Nil => Cons(t1, zs_next), // Always true
  Cons(l_data, l_next) =>
    Cons(
      l_data,
      append(l_next, Cons(t1, zs_next))
    )
}

// when l = Cons(l_data, l_next)

zs_next != Cons(l_data, append(l_next, Cons(t1, zs_next)))

// Let that thing be lemma_2
```

# Checking `lemma_2`

```rust
l1 != Cons(t, append(l2, Cons(t1, l1)))

// Definition of append

l1 != Cons(t, match l2 {
  Nil => Cons(t1, l1),
  Cons(l2_data, l2_next) => Cons(
    l2_data,
    append(l2_next, Cons(t1, l1))
  )
})

// When l2 is nil, trivial.
// When l2 is Cons:

l1 != Cons(l2_data, append(l2_next, Cons(t1, l1)))

// huh.
```

Some attempts.
