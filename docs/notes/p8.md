
# Decomposition attempt 3 (2/13/26)

Given

```rust
#[define]
#[recursive]
pub fn append<T: PartialEq>(x: LinkedList<T>, y: LinkedList<T>) -> LinkedList<T> {
  match x {
    LinkedList::<T>::Nil => y,
    LinkedList::<T>::Cons(z, xs) => LinkedList::<T>::Cons(z, Box::new(append::<T>(*xs, y)))
  }
}
```

WTS

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(xs: LinkedList<T>, ys: LinkedList<T>, zs: LinkedList<T>)]
fn injectivity_of_append<T>() -> bool {
  implies(
    append::<T>(xs, zs) == append::<T>(ys, zs),
    xs == ys
  )
}
```

We apply the definition of append.

```rust
implies(
  append(xs, zs) == append(ys, zs),
  xs == ys
)

// Becomes

implies(
  match xs {
    Nil => zs,
    Cons(xs_data, xs_next) =>
      Cons(xs_data, append(*xs_next, zs))
  } == match ys {
    Nil => zs,
    Cons(ys_data, ys_next) =>
      Cons(ys_data, append(*ys_next, zs))
  },
  xs == ys
)
```

We examine this in four cases.

## Case 1: `xs = ys = Nil`

The premise becomes `zs == zs`, which is true. The consequence
becomes `Nil == Nil`, which is also true. Therefore, this case
holds.

## Case 2: `xs = Nil, ys = Cons(t1, l1)`

The premise becomes `zs == Cons(t1, append(l1, zs))`. The
consequence becomes `Nil == Cons(t1, l1)`, which is false.
Therefore, we need to prove that the premise is also false.

Equivalently, given `zs, t1` and `l1`, WTS
`zs != Cons(t1, append(l1, zs))`. We will create a lemma to
show this.

### C2.L1

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>, l: LinkedList<T>)]
fn case_2_lemma_1<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(l, zs))
}
```

If we rewrite this as an assumption, it causes the overall case
to pass. Therefore, it is sufficient to prove this.

## Case 3: `xs = Cons(t1, l1), ys = Nil`

The premise becomes `Cons(t1, append(l1, zs)) == Nil`. The
consequence becomes `Cons(t1, l1) == Nil`, which is
false. By commutativity of equality,
`Cons(t1, append(l1, zs)) == Nil` iff
`Nil == Cons(t1, append(l1, zs))`. This was proved in the
previous step, so this case holds.

## Case 4: `xs = Cons(t1, l1), ys = Cons(t2, l2)`

The premise becomes
`Cons(t1, append(l1, zs)) == Cons(t2, append(l2, zs))`. The
consequence becomes `Cons(t1, l1) == Cons(t2, l2)`.

Assuming the premise, we know that `t1 == t2` and
`append(l1, zs) == append(l2, zs)`. By the inductive hypothesis,
we know that `append(l1, zs) == append(l2, zs)` implies
`l1 == l2`. Since `t1 == t2` and `l1 == l2`, the consequence is
true. This case holds.

# Proving lemmas

## L1

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(zs: LinkedList<T>, l: LinkedList<T>)]
fn lemma_1<T>(t: T) -> bool {
  zs != LinkedList::<T>::Cons(t, append::<T>(l, zs))
}
```

All cases verify except the one where neither `zs` nor `l` are
nil.

Assume neither are nil: `zs = Cons(t1, l1), l = Cons(t2, l2)`.

```rust
#[annotate]
#[for_type(LinkedList<T> => <T>)]
#[inductive(l1: LinkedList<T>, l2: LinkedList<T>)]
fn lemma_1_neither_nil<T>(t: T, t1: T, t2: T) -> bool {
  LinkedList::<T>::Cons(t1, l1) != LinkedList::<T>::Cons(
    t,
    append::<T>(
      LinkedList::<T>::Cons(t2, l2),
      LinkedList::<T>::Cons(t1, l1)
    )
  )
}
```

However, somehow this is insufficient to imply lemma 1, even
with all the other cases? We'll still try to prove it.
