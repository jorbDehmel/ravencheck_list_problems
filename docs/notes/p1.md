
This problem introduces the recursive function pair
`evens`/`odds`. They both depend on each other, which I don't
know how to communicate to ravencheck. The following is the
direct implementation.

```rust
#[define]
#[recursive]
fn evens(x: LinkedList) -> LinkedList {
  match x {
    LinkedList::Nil => LinkedList::Nil,
    LinkedList::Cons(y, xs) => LinkedList::Cons(
      y,
      Box::new(odds(*xs))
    )
  }
}

#[define]
#[recursive]
fn odds(x: LinkedList) -> LinkedList {
  match x {
    LinkedList::Nil => LinkedList::Nil,
    LinkedList::Cons(_, xs) => evens(*xs)
  }
}
```

One approach is to unroll the calls until they are only
recursive and not co-dependent.

```rust
#[define]
#[recursive]
fn evens(x: LinkedList) -> LinkedList {
  match x {
    LinkedList::Nil => LinkedList::Nil,
    LinkedList::Cons(y, xs) => LinkedList::Cons(
      y,
      Box::new(
        // This is just odds(*xs)
        match *xs {
          LinkedList::Nil => LinkedList::Nil,
          LinkedList::Cons(_data, xss) => evens(*xss)
        }
      )
    )
  }
}

// Odds can stay, now that we've defined evens
#[define]
#[recursive]
fn odds(x: LinkedList) -> LinkedList {
  match x {
    LinkedList::Nil => LinkedList::Nil,
    LinkedList::Cons(_, xs) => evens(*xs)
  }
}
```

This is definitely cheating, but it'll work until I figure out
how to actually do it (and it's logically equivalent). Then we
run into this problem.

```rust
#[annotate_multi]
#[for_values(xs: LinkedList)]
#[for_call(evens(xs) => evens_xs)]
#[for_call(odds(xs) => odds_xs)]
#[for_call(interleave(evens_xs, odds_xs) => interleaved)]
fn to_prove() -> bool {
  interleaved == xs
}
```

```
type error in generated vc for 'to_prove': "Op 'evens_xs' is undefined"
```

Which occurs because I'm trying to use the output of one
`for_call` in another.

My naive approach here is to introduce auxiliary variables.

```rust
#[annotate_multi]
#[for_values(xs: LinkedList, aux1: LinkedList, aux2: LinkedList)]
#[for_call(evens(xs) => evens_xs)]
#[for_call(odds(xs) => odds_xs)]
#[for_call(interleave(aux1, aux2) => interleaved)]
fn to_prove() -> bool {
  implies(
    aux1 == evens_xs && aux2 == odds_xs,
    interleaved == xs
  )
}
```

Now we just have `> Failed to verify 'to_prove': solver found counterexample`.

Similar corrections yield the same result on p2, p3, p4.
