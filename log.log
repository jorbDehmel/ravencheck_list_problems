
running 1 test
test p8::p8::ravencheck_tests::check_properties ... FAILED

failures:

---- p8::p8::ravencheck_tests::check_properties stdout ----
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []
Pushing axiom with rules []

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(12))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true)]), [Atom(Auto(13))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(12))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true)]), [Atom(Auto(13))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(12), [], None, true)]), Auto(32), Bind1(LogNot(Var(Auto(32), [], None, true)), Auto(27), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true)]), [Atom(Auto(13))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(27), [], None, true)]), Auto(30), Return([Var(Auto(30), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(12), [], None, true)]), Auto(32), Bind1(LogNot(Var(Auto(32), [], None, true)), Auto(27), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true)]), [Atom(Auto(13))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(27), [], None, true)]), Auto(30), Return([Var(Auto(30), [], None, true)])))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true), Var(Auto(13), [], None, true)]), Auto(45), Bind1(LogNot(Var(Auto(45), [], None, true)), Auto(40), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Return([Var(Auto(43), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true), Var(Auto(13), [], None, true)]), Auto(45), Bind1(LogNot(Var(Auto(45), [], None, true)), Auto(40), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Auto(13), [], None, true)]), [Atom(Auto(14))], Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Return([Var(Auto(43), [], None, true)])))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(13), [], None, true), Var(Auto(14), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(46), [], None, true)]), Auto(43), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(13), [], None, true), Var(Auto(14), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(46), [], None, true)]), Auto(43), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))
Checking 1 cases...

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(12), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(12), [], None, true)]), Auto(33), Bind1(LogQuantifier(Forall, [(Auto(13), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true), Var(Auto(13), [], None, true)]), Auto(46), Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(13), [], None, true), Var(Auto(14), [], None, true)]), Auto(58), Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(46), [], None, true)]), Auto(43), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(44), Return([Var(Auto(44), [], None, true)])))), Auto(31), Return([Var(Auto(31), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(60), Return([Var(Auto(60), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(12), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(12), [], None, true)]), Auto(33), Bind1(LogQuantifier(Forall, [(Auto(13), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true), Var(Auto(13), [], None, true)]), Auto(46), Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(13), [], None, true), Var(Auto(14), [], None, true)]), Auto(58), Bind1(Eq(true, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(17), Bind1(LogOpN(Or, [Var(Auto(17), [], None, true), Var(Auto(33), [], None, true)]), Auto(30), Bind1(LogOpN(Or, [Var(Auto(30), [], None, true), Var(Auto(46), [], None, true)]), Auto(43), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(44), Return([Var(Auto(44), [], None, true)])))), Auto(31), Return([Var(Auto(31), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(60), Return([Var(Auto(60), [], None, true)])))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "append", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "data", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }} }

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "data", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "append", types: [], path: None }} }
Declared T as UI_T
Declared LinkedList<T> as UI_LinkedList__UI_T__
###
### Declaring op OpCode { ident: "chop", types: [], path: None } to smt solver...
###

Declared chop as absrel F_chop____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for chop]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_chop____ xn_0 xn_4)) (not (F_chop____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "cons", types: [], path: None } to smt solver...
###

Declared cons as absrel F_cons____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for cons]: (forall ((xn_0 UI_T) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_cons____ xn_0 xn_1 xn_5)) (not (F_cons____ xn_0 xn_1 xn_3)))))))
###
### Declaring op OpCode { ident: "next", types: [], path: None } to smt solver...
###

Declared next as absrel F_next____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for next]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_next____ xn_0 xn_4)) (not (F_next____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "data", types: [], path: None } to smt solver...
###

Declared data as absrel F_data____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for data]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_T)) (forall ((xn_4 UI_T)) (or (= xn_2 xn_4) (or (not (F_data____ xn_0 xn_4)) (not (F_data____ xn_0 xn_2)))))))
Declared NIL as constant F_NIL____
###
### Declaring op OpCode { ident: "append", types: [], path: None } to smt solver...
###

Declared append as absrel F_append____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for append]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_append____ xn_0 xn_1 xn_5)) (not (F_append____ xn_0 xn_1 xn_3)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_14 UI_LinkedList__UI_T__)) (forall ((xn_15 UI_LinkedList__UI_T__)) (or (or (or (= xn_15 xn_14) (distinct x_x x_y)) (not (F_chop____ x_y xn_14))) (not (F_chop____ x_x xn_15))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__) (x_b UI_LinkedList__UI_T__)) (or (distinct x_a x_b) (= x_a x_b)))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (or true (not (F_next____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_T)) (or true (not (F_data____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_y UI_LinkedList__UI_T__)) (forall ((xn_26 UI_LinkedList__UI_T__)) (forall ((xn_27 UI_LinkedList__UI_T__)) (forall ((xn_28 UI_LinkedList__UI_T__)) (forall ((xn_35 UI_LinkedList__UI_T__)) (forall ((xn_36 UI_LinkedList__UI_T__)) (forall ((xn_37 UI_T)) (or (or (or (or (or (or (and (= xn_37 x_a) (= xn_28 x_y)) (not (F_cons____ x_a F_NIL____ xn_26))) (not (F_append____ xn_26 x_y xn_27))) (not (F_next____ xn_27 xn_28))) (not (F_cons____ x_a F_NIL____ xn_35))) (not (F_append____ xn_35 x_y xn_36))) (not (F_data____ xn_36 xn_37))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_b UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (= xn_23 xn_22) (or (distinct x_x x_y) (distinct x_a x_b))) (not (F_cons____ x_b x_y xn_22))) (not (F_cons____ x_a x_x xn_23))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_9 UI_LinkedList__UI_T__)) (forall ((xn_10 UI_T)) (or (or (= xn_10 x_a) (not (F_cons____ x_a x_x xn_9))) (not (F_data____ xn_9 xn_10))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))


SMT Axiom: (and (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_68 UI_T)) (forall ((xn_69 UI_LinkedList__UI_T__)) (forall ((xn_76 UI_LinkedList__UI_T__)) (forall ((xn_91 UI_LinkedList__UI_T__)) (forall ((xn_98 UI_T)) (forall ((xn_99 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (and (or (= xn_91 x_y) (or (distinct x_x xn_99) (distinct x_a xn_98))) (or (and (= x_x xn_69) (= x_a xn_68)) (distinct xn_76 x_y))) (not (F_data____ x_y xn_68))) (not (F_next____ x_y xn_69))) (not (F_cons____ x_a x_x xn_76))) (not (F_cons____ x_a x_x xn_91))) (not (F_data____ x_y xn_98))) (not (F_next____ x_y xn_99)))))))))) (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_60 UI_LinkedList__UI_T__)) (forall ((xn_61 UI_LinkedList__UI_T__)) (or (or (= xn_61 x_x) (not (F_cons____ x_a x_x xn_60))) (not (F_next____ xn_60 xn_61)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_50 UI_T)) (forall ((xn_51 UI_T)) (forall ((xn_52 UI_LinkedList__UI_T__)) (forall ((xn_53 UI_LinkedList__UI_T__)) (forall ((xn_80 UI_T)) (forall ((xn_81 UI_T)) (forall ((xn_82 UI_LinkedList__UI_T__)) (forall ((xn_83 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (or (or (and (or (= x_x x_y) (or (distinct xn_83 xn_82) (distinct xn_80 xn_81))) (or (and (= xn_53 xn_52) (= xn_50 xn_51)) (distinct x_x x_y))) (not (F_data____ x_x xn_50))) (not (F_data____ x_y xn_51))) (not (F_next____ x_y xn_52))) (not (F_next____ x_x xn_53))) (not (F_data____ x_x xn_80))) (not (F_data____ x_y xn_81))) (not (F_next____ x_y xn_82))) (not (F_next____ x_x xn_83))))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__)) (forall ((xn_7 UI_LinkedList__UI_T__)) (or (= xn_7 x_x) (not (F_append____ x_x F_NIL____ xn_7)))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_chop____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_a UI_T) (x_b UI_T)) (forall ((xn_16 UI_LinkedList__UI_T__)) (forall ((xn_17 UI_LinkedList__UI_T__)) (or (or (or (= x_a x_b) (distinct xn_17 xn_16)) (not (F_cons____ x_b x_x xn_16))) (not (F_cons____ x_a x_x xn_17))))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_next____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_19 UI_LinkedList__UI_T__)) (forall ((xn_20 UI_LinkedList__UI_T__)) (forall ((xn_21 UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (or (or (= xn_23 xn_21) (not (F_cons____ x_t F_NIL____ xn_19))) (not (F_append____ x_x xn_19 xn_20))) (not (F_append____ xn_20 x_y xn_21))) (not (F_cons____ x_t x_y xn_22))) (not (F_append____ x_x xn_22 xn_23)))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_l UI_LinkedList__UI_T__) (x_r UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_37 UI_LinkedList__UI_T__)) (forall ((xn_38 UI_LinkedList__UI_T__)) (forall ((xn_39 UI_LinkedList__UI_T__)) (forall ((xn_66 UI_LinkedList__UI_T__)) (forall ((xn_67 UI_LinkedList__UI_T__)) (or (or (or (or (or (and (or (= x_l x_r) (distinct xn_67 xn_66)) (or (= xn_39 xn_38) (distinct x_l x_r))) (not (F_cons____ x_t F_NIL____ xn_37))) (not (F_append____ x_r xn_37 xn_38))) (not (F_append____ x_l xn_37 xn_39))) (not (F_append____ x_r xn_37 xn_66))) (not (F_append____ x_l xn_37 xn_67)))))))))


Called smt on Bind1(LogQuantifier(Exists, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", [])))], Bind1(LogQuantifier(Exists, [(Auto(12), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(12), [], None, true)]), Auto(77), Bind1(LogQuantifier(Exists, [(Auto(13), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(12), [], None, true), Var(Auto(13), [], None, true)]), Auto(75), Bind1(LogQuantifier(Exists, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(13), [], None, true), Var(Auto(14), [], None, true)]), Auto(73), Bind1(Eq(false, [Var(Auto(14), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(76), Bind1(LogOpN(And, [Var(Auto(76), [], None, true), Var(Auto(77), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(73), [], None, true)]), Auto(71), Return([Var(Auto(71), [], None, true)]))))))), Auto(68), Return([Var(Auto(68), [], None, true)])))), Auto(65), Return([Var(Auto(65), [], None, true)])))), Auto(62), Return([Var(Auto(62), [], None, true)]))), Auto(59), Return([Var(Auto(59), [], None, true)]))


SMT: (exists ((x_x UI_LinkedList__UI_T__) (x_a UI_T)) (exists ((xn_12 UI_LinkedList__UI_T__)) (exists ((xn_13 UI_LinkedList__UI_T__)) (exists ((xn_14 UI_LinkedList__UI_T__)) (and (and (and (distinct xn_14 x_x) (F_cons____ x_a F_NIL____ xn_12)) (F_append____ x_x xn_12 xn_13)) (F_chop____ xn_13 xn_14))))))
Got SAT for case [root]

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(10))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(11))], Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Return([Var(Auto(14), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(10))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(11))], Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Return([Var(Auto(14), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(10), [], None, true)]), Auto(29), Bind1(LogNot(Var(Auto(29), [], None, true)), Auto(24), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(11))], Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(24), [], None, true)]), Auto(27), Return([Var(Auto(27), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(10), [], None, true)]), Auto(29), Bind1(LogNot(Var(Auto(29), [], None, true)), Auto(24), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(11))], Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(24), [], None, true)]), Auto(27), Return([Var(Auto(27), [], None, true)]))))))
Expanding call unappend...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(11), [], None, true)]), Auto(42), Bind1(LogNot(Var(Auto(42), [], None, true)), Auto(37), Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(30), [], None, true)]), Auto(27), Bind1(LogOpN(Or, [Var(Auto(27), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(11), [], None, true)]), Auto(42), Bind1(LogNot(Var(Auto(42), [], None, true)), Auto(37), Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(30), [], None, true)]), Auto(27), Bind1(LogOpN(Or, [Var(Auto(27), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)]))))))
Checking 1 cases...

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(10), [], None, true)]), Auto(30), Bind1(LogQuantifier(Forall, [(Auto(11), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(11), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(30), [], None, true)]), Auto(27), Bind1(LogOpN(Or, [Var(Auto(27), [], None, true), Var(Auto(43), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))), Auto(41), Return([Var(Auto(41), [], None, true)])))), Auto(28), Return([Var(Auto(28), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(45), Return([Var(Auto(45), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(10), [], None, true)]), Auto(30), Bind1(LogQuantifier(Forall, [(Auto(11), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(11), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(14), Bind1(LogOpN(Or, [Var(Auto(14), [], None, true), Var(Auto(30), [], None, true)]), Auto(27), Bind1(LogOpN(Or, [Var(Auto(27), [], None, true), Var(Auto(43), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))), Auto(41), Return([Var(Auto(41), [], None, true)])))), Auto(28), Return([Var(Auto(28), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(45), Return([Var(Auto(45), [], None, true)])))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "data", types: [], path: None }, OpCode { ident: "unappend", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "append", types: [], path: None }} }

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "append", types: [], path: None }, OpCode { ident: "data", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "unappend", types: [], path: None }} }
Declared T as UI_T
Declared LinkedList<T> as UI_LinkedList__UI_T__
Declared NIL as constant F_NIL____
###
### Declaring op OpCode { ident: "cons", types: [], path: None } to smt solver...
###

Declared cons as absrel F_cons____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for cons]: (forall ((xn_0 UI_T) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_cons____ xn_0 xn_1 xn_5)) (not (F_cons____ xn_0 xn_1 xn_3)))))))
###
### Declaring op OpCode { ident: "append", types: [], path: None } to smt solver...
###

Declared append as absrel F_append____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for append]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_append____ xn_0 xn_1 xn_5)) (not (F_append____ xn_0 xn_1 xn_3)))))))
###
### Declaring op OpCode { ident: "data", types: [], path: None } to smt solver...
###

Declared data as absrel F_data____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for data]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_T)) (forall ((xn_4 UI_T)) (or (= xn_2 xn_4) (or (not (F_data____ xn_0 xn_4)) (not (F_data____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "chop", types: [], path: None } to smt solver...
###

Declared chop as absrel F_chop____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for chop]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_chop____ xn_0 xn_4)) (not (F_chop____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "next", types: [], path: None } to smt solver...
###

Declared next as absrel F_next____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for next]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_next____ xn_0 xn_4)) (not (F_next____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "unappend", types: [], path: None } to smt solver...
###

Declared unappend as absrel F_unappend____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for unappend]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_unappend____ xn_0 xn_1 xn_5)) (not (F_unappend____ xn_0 xn_1 xn_3)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_14 UI_LinkedList__UI_T__)) (forall ((xn_15 UI_LinkedList__UI_T__)) (or (or (or (= xn_15 xn_14) (distinct x_x x_y)) (not (F_chop____ x_y xn_14))) (not (F_chop____ x_x xn_15))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__) (x_b UI_LinkedList__UI_T__)) (or (distinct x_a x_b) (= x_a x_b)))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (or true (not (F_next____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_T)) (or true (not (F_data____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_y UI_LinkedList__UI_T__)) (forall ((xn_26 UI_LinkedList__UI_T__)) (forall ((xn_27 UI_LinkedList__UI_T__)) (forall ((xn_28 UI_LinkedList__UI_T__)) (forall ((xn_35 UI_LinkedList__UI_T__)) (forall ((xn_36 UI_LinkedList__UI_T__)) (forall ((xn_37 UI_T)) (or (or (or (or (or (or (and (= xn_37 x_a) (= xn_28 x_y)) (not (F_cons____ x_a F_NIL____ xn_26))) (not (F_append____ xn_26 x_y xn_27))) (not (F_next____ xn_27 xn_28))) (not (F_cons____ x_a F_NIL____ xn_35))) (not (F_append____ xn_35 x_y xn_36))) (not (F_data____ xn_36 xn_37))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_b UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (= xn_23 xn_22) (or (distinct x_x x_y) (distinct x_a x_b))) (not (F_cons____ x_b x_y xn_22))) (not (F_cons____ x_a x_x xn_23))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_9 UI_LinkedList__UI_T__)) (forall ((xn_10 UI_T)) (or (or (= xn_10 x_a) (not (F_cons____ x_a x_x xn_9))) (not (F_data____ xn_9 xn_10))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))


SMT Axiom: (and (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_68 UI_T)) (forall ((xn_69 UI_LinkedList__UI_T__)) (forall ((xn_76 UI_LinkedList__UI_T__)) (forall ((xn_91 UI_LinkedList__UI_T__)) (forall ((xn_98 UI_T)) (forall ((xn_99 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (and (or (= xn_91 x_y) (or (distinct x_x xn_99) (distinct x_a xn_98))) (or (and (= x_x xn_69) (= x_a xn_68)) (distinct xn_76 x_y))) (not (F_data____ x_y xn_68))) (not (F_next____ x_y xn_69))) (not (F_cons____ x_a x_x xn_76))) (not (F_cons____ x_a x_x xn_91))) (not (F_data____ x_y xn_98))) (not (F_next____ x_y xn_99)))))))))) (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_60 UI_LinkedList__UI_T__)) (forall ((xn_61 UI_LinkedList__UI_T__)) (or (or (= xn_61 x_x) (not (F_cons____ x_a x_x xn_60))) (not (F_next____ xn_60 xn_61)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_50 UI_T)) (forall ((xn_51 UI_T)) (forall ((xn_52 UI_LinkedList__UI_T__)) (forall ((xn_53 UI_LinkedList__UI_T__)) (forall ((xn_80 UI_T)) (forall ((xn_81 UI_T)) (forall ((xn_82 UI_LinkedList__UI_T__)) (forall ((xn_83 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (or (or (and (or (= x_x x_y) (or (distinct xn_83 xn_82) (distinct xn_80 xn_81))) (or (and (= xn_53 xn_52) (= xn_50 xn_51)) (distinct x_x x_y))) (not (F_data____ x_x xn_50))) (not (F_data____ x_y xn_51))) (not (F_next____ x_y xn_52))) (not (F_next____ x_x xn_53))) (not (F_data____ x_x xn_80))) (not (F_data____ x_y xn_81))) (not (F_next____ x_y xn_82))) (not (F_next____ x_x xn_83))))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__)) (forall ((xn_7 UI_LinkedList__UI_T__)) (or (= xn_7 x_x) (not (F_append____ x_x F_NIL____ xn_7)))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_chop____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_a UI_T) (x_b UI_T)) (forall ((xn_16 UI_LinkedList__UI_T__)) (forall ((xn_17 UI_LinkedList__UI_T__)) (or (or (or (= x_a x_b) (distinct xn_17 xn_16)) (not (F_cons____ x_b x_x xn_16))) (not (F_cons____ x_a x_x xn_17))))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_next____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_19 UI_LinkedList__UI_T__)) (forall ((xn_20 UI_LinkedList__UI_T__)) (forall ((xn_21 UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (or (or (= xn_23 xn_21) (not (F_cons____ x_t F_NIL____ xn_19))) (not (F_append____ x_x xn_19 xn_20))) (not (F_append____ xn_20 x_y xn_21))) (not (F_cons____ x_t x_y xn_22))) (not (F_append____ x_x xn_22 xn_23)))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_l UI_LinkedList__UI_T__) (x_r UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_37 UI_LinkedList__UI_T__)) (forall ((xn_38 UI_LinkedList__UI_T__)) (forall ((xn_39 UI_LinkedList__UI_T__)) (forall ((xn_66 UI_LinkedList__UI_T__)) (forall ((xn_67 UI_LinkedList__UI_T__)) (or (or (or (or (or (and (or (= x_l x_r) (distinct xn_67 xn_66)) (or (= xn_39 xn_38) (distinct x_l x_r))) (not (F_cons____ x_t F_NIL____ xn_37))) (not (F_append____ x_r xn_37 xn_38))) (not (F_append____ x_l xn_37 xn_39))) (not (F_append____ x_r xn_37 xn_66))) (not (F_append____ x_l xn_37 xn_67)))))))))


Called smt on Bind1(LogQuantifier(Exists, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Exists, [(Auto(10), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(10), [], None, true)]), Auto(57), Bind1(LogQuantifier(Exists, [(Auto(11), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(10), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(11), [], None, true)]), Auto(55), Bind1(Eq(false, [Var(Auto(11), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(57), [], None, true)]), Auto(54), Bind1(LogOpN(And, [Var(Auto(54), [], None, true), Var(Auto(55), [], None, true)]), Auto(53), Return([Var(Auto(53), [], None, true)])))))), Auto(50), Return([Var(Auto(50), [], None, true)])))), Auto(47), Return([Var(Auto(47), [], None, true)]))), Auto(44), Return([Var(Auto(44), [], None, true)]))


SMT: (exists ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (exists ((xn_10 UI_LinkedList__UI_T__)) (exists ((xn_11 UI_LinkedList__UI_T__)) (and (and (distinct xn_11 x_x) (F_append____ x_x x_y xn_10)) (F_unappend____ xn_10 x_y xn_11)))))
Got SAT for case [root]

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("z"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(34))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(35))], Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(49), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(true, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(66), Bind1(LogNot(Var(Auto(66), [], None, true)), Auto(71), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(71), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Return([Var(Auto(33), [], None, true)]))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("z"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(34))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(35))], Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(49), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(true, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(66), Bind1(LogNot(Var(Auto(66), [], None, true)), Auto(71), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(71), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Return([Var(Auto(33), [], None, true)]))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call unappend...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(34), [], None, true)]), Auto(91), Bind1(LogNot(Var(Auto(91), [], None, true)), Auto(86), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(35))], Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(86), [], None, true)]), Auto(89), Return([Var(Auto(89), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(34), [], None, true)]), Auto(91), Bind1(LogNot(Var(Auto(91), [], None, true)), Auto(86), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(35))], Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(86), [], None, true)]), Auto(89), Return([Var(Auto(89), [], None, true)]))))))))))))))
Expanding call unappend...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(35), [], None, true)]), Auto(104), Bind1(LogNot(Var(Auto(104), [], None, true)), Auto(99), Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(99), [], None, true)]), Auto(102), Return([Var(Auto(102), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(35), [], None, true)]), Auto(104), Bind1(LogNot(Var(Auto(104), [], None, true)), Auto(99), Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(62))], BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(99), [], None, true)]), Auto(102), Return([Var(Auto(102), [], None, true)]))))))))))))))
Expanding call unappend...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(62), [], None, true)]), Auto(117), Bind1(LogNot(Var(Auto(117), [], None, true)), Auto(112), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(112), [], None, true)]), Auto(115), Return([Var(Auto(115), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(62), [], None, true)]), Auto(117), Bind1(LogNot(Var(Auto(117), [], None, true)), Auto(112), BindN(Call(OpCode { ident: "unappend", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true)]), [Atom(Auto(63))], Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(112), [], None, true)]), Auto(115), Return([Var(Auto(115), [], None, true)]))))))))))
Expanding call unappend...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(63), [], None, true)]), Auto(130), Bind1(LogNot(Var(Auto(130), [], None, true)), Auto(125), Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(118), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(125), [], None, true)]), Auto(128), Return([Var(Auto(128), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(63), [], None, true)]), Auto(130), Bind1(LogNot(Var(Auto(130), [], None, true)), Auto(125), Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(118), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(125), [], None, true)]), Auto(128), Return([Var(Auto(128), [], None, true)]))))))))))
Checking 1 cases...

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("z"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(34), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(34), [], None, true)]), Auto(92), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(35), [], None, true)]), Auto(105), Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), Bind1(LogQuantifier(Forall, [(Auto(62), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(62), [], None, true)]), Auto(118), Bind1(LogQuantifier(Forall, [(Auto(63), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(63), [], None, true)]), Auto(131), Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(118), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(131), [], None, true)]), Auto(128), Return([Var(Auto(128), [], None, true)])))))))))), Auto(129), Return([Var(Auto(129), [], None, true)])))), Auto(116), Return([Var(Auto(116), [], None, true)])))))))), Auto(103), Return([Var(Auto(103), [], None, true)])))), Auto(90), Return([Var(Auto(90), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(133), Return([Var(Auto(133), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("z"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(34), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(34), [], None, true)]), Auto(92), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(35), [], None, true)]), Auto(105), Bind1(Eq(true, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(38), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogOpN(Or, [Var(Auto(38), [], None, true), Var(Auto(79), [], None, true)]), Auto(52), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(58), Bind1(LogQuantifier(Forall, [(Auto(62), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(62), [], None, true)]), Auto(118), Bind1(LogQuantifier(Forall, [(Auto(63), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(63), [], None, true)]), Auto(131), Bind1(Eq(false, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(58), [], None, true), Var(Auto(78), [], None, true)]), Auto(74), Bind1(LogOpN(And, [Var(Auto(74), [], None, true), Var(Auto(52), [], None, true)]), Auto(33), Bind1(LogOpN(Or, [Var(Auto(33), [], None, true), Var(Auto(92), [], None, true)]), Auto(89), Bind1(LogOpN(Or, [Var(Auto(89), [], None, true), Var(Auto(105), [], None, true)]), Auto(102), Bind1(LogOpN(Or, [Var(Auto(102), [], None, true), Var(Auto(118), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(131), [], None, true)]), Auto(128), Return([Var(Auto(128), [], None, true)])))))))))), Auto(129), Return([Var(Auto(129), [], None, true)])))), Auto(116), Return([Var(Auto(116), [], None, true)])))))))), Auto(103), Return([Var(Auto(103), [], None, true)])))), Auto(90), Return([Var(Auto(90), [], None, true)]))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(133), Return([Var(Auto(133), [], None, true)])))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "data", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "unappend", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "append", types: [], path: None }} }

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("LinkedList", [Base(UI("T", []))]), UI("T", [])}, ops: {OpCode { ident: "data", types: [], path: None }, OpCode { ident: "append", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "unappend", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }} }
Declared LinkedList<T> as UI_LinkedList__UI_T__
Declared T as UI_T
###
### Declaring op OpCode { ident: "data", types: [], path: None } to smt solver...
###

Declared data as absrel F_data____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for data]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_T)) (forall ((xn_4 UI_T)) (or (= xn_2 xn_4) (or (not (F_data____ xn_0 xn_4)) (not (F_data____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "append", types: [], path: None } to smt solver...
###

Declared append as absrel F_append____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for append]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_append____ xn_0 xn_1 xn_5)) (not (F_append____ xn_0 xn_1 xn_3)))))))
###
### Declaring op OpCode { ident: "next", types: [], path: None } to smt solver...
###

Declared next as absrel F_next____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for next]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_next____ xn_0 xn_4)) (not (F_next____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "chop", types: [], path: None } to smt solver...
###

Declared chop as absrel F_chop____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for chop]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_chop____ xn_0 xn_4)) (not (F_chop____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "unappend", types: [], path: None } to smt solver...
###

Declared unappend as absrel F_unappend____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for unappend]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_unappend____ xn_0 xn_1 xn_5)) (not (F_unappend____ xn_0 xn_1 xn_3)))))))
Declared NIL as constant F_NIL____
###
### Declaring op OpCode { ident: "cons", types: [], path: None } to smt solver...
###

Declared cons as absrel F_cons____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for cons]: (forall ((xn_0 UI_T) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_cons____ xn_0 xn_1 xn_5)) (not (F_cons____ xn_0 xn_1 xn_3)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_14 UI_LinkedList__UI_T__)) (forall ((xn_15 UI_LinkedList__UI_T__)) (or (or (or (= xn_15 xn_14) (distinct x_x x_y)) (not (F_chop____ x_y xn_14))) (not (F_chop____ x_x xn_15))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__) (x_b UI_LinkedList__UI_T__)) (or (distinct x_a x_b) (= x_a x_b)))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (or true (not (F_next____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_T)) (or true (not (F_data____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_y UI_LinkedList__UI_T__)) (forall ((xn_26 UI_LinkedList__UI_T__)) (forall ((xn_27 UI_LinkedList__UI_T__)) (forall ((xn_28 UI_LinkedList__UI_T__)) (forall ((xn_35 UI_LinkedList__UI_T__)) (forall ((xn_36 UI_LinkedList__UI_T__)) (forall ((xn_37 UI_T)) (or (or (or (or (or (or (and (= xn_37 x_a) (= xn_28 x_y)) (not (F_cons____ x_a F_NIL____ xn_26))) (not (F_append____ xn_26 x_y xn_27))) (not (F_next____ xn_27 xn_28))) (not (F_cons____ x_a F_NIL____ xn_35))) (not (F_append____ xn_35 x_y xn_36))) (not (F_data____ xn_36 xn_37))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_b UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (= xn_23 xn_22) (or (distinct x_x x_y) (distinct x_a x_b))) (not (F_cons____ x_b x_y xn_22))) (not (F_cons____ x_a x_x xn_23))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_9 UI_LinkedList__UI_T__)) (forall ((xn_10 UI_T)) (or (or (= xn_10 x_a) (not (F_cons____ x_a x_x xn_9))) (not (F_data____ xn_9 xn_10))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))


SMT Axiom: (and (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_68 UI_T)) (forall ((xn_69 UI_LinkedList__UI_T__)) (forall ((xn_76 UI_LinkedList__UI_T__)) (forall ((xn_91 UI_LinkedList__UI_T__)) (forall ((xn_98 UI_T)) (forall ((xn_99 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (and (or (= xn_91 x_y) (or (distinct x_x xn_99) (distinct x_a xn_98))) (or (and (= x_x xn_69) (= x_a xn_68)) (distinct xn_76 x_y))) (not (F_data____ x_y xn_68))) (not (F_next____ x_y xn_69))) (not (F_cons____ x_a x_x xn_76))) (not (F_cons____ x_a x_x xn_91))) (not (F_data____ x_y xn_98))) (not (F_next____ x_y xn_99)))))))))) (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_60 UI_LinkedList__UI_T__)) (forall ((xn_61 UI_LinkedList__UI_T__)) (or (or (= xn_61 x_x) (not (F_cons____ x_a x_x xn_60))) (not (F_next____ xn_60 xn_61)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_50 UI_T)) (forall ((xn_51 UI_T)) (forall ((xn_52 UI_LinkedList__UI_T__)) (forall ((xn_53 UI_LinkedList__UI_T__)) (forall ((xn_80 UI_T)) (forall ((xn_81 UI_T)) (forall ((xn_82 UI_LinkedList__UI_T__)) (forall ((xn_83 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (or (or (and (or (= x_x x_y) (or (distinct xn_83 xn_82) (distinct xn_80 xn_81))) (or (and (= xn_53 xn_52) (= xn_50 xn_51)) (distinct x_x x_y))) (not (F_data____ x_x xn_50))) (not (F_data____ x_y xn_51))) (not (F_next____ x_y xn_52))) (not (F_next____ x_x xn_53))) (not (F_data____ x_x xn_80))) (not (F_data____ x_y xn_81))) (not (F_next____ x_y xn_82))) (not (F_next____ x_x xn_83))))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__)) (forall ((xn_7 UI_LinkedList__UI_T__)) (or (= xn_7 x_x) (not (F_append____ x_x F_NIL____ xn_7)))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_chop____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_a UI_T) (x_b UI_T)) (forall ((xn_16 UI_LinkedList__UI_T__)) (forall ((xn_17 UI_LinkedList__UI_T__)) (or (or (or (= x_a x_b) (distinct xn_17 xn_16)) (not (F_cons____ x_b x_x xn_16))) (not (F_cons____ x_a x_x xn_17))))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_next____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_19 UI_LinkedList__UI_T__)) (forall ((xn_20 UI_LinkedList__UI_T__)) (forall ((xn_21 UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (or (or (= xn_23 xn_21) (not (F_cons____ x_t F_NIL____ xn_19))) (not (F_append____ x_x xn_19 xn_20))) (not (F_append____ xn_20 x_y xn_21))) (not (F_cons____ x_t x_y xn_22))) (not (F_append____ x_x xn_22 xn_23)))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_l UI_LinkedList__UI_T__) (x_r UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_37 UI_LinkedList__UI_T__)) (forall ((xn_38 UI_LinkedList__UI_T__)) (forall ((xn_39 UI_LinkedList__UI_T__)) (forall ((xn_66 UI_LinkedList__UI_T__)) (forall ((xn_67 UI_LinkedList__UI_T__)) (or (or (or (or (or (and (or (= x_l x_r) (distinct xn_67 xn_66)) (or (= xn_39 xn_38) (distinct x_l x_r))) (not (F_cons____ x_t F_NIL____ xn_37))) (not (F_append____ x_r xn_37 xn_38))) (not (F_append____ x_l xn_37 xn_39))) (not (F_append____ x_r xn_37 xn_66))) (not (F_append____ x_l xn_37 xn_67)))))))))


Called smt on Bind1(LogQuantifier(Exists, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("z"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Exists, [(Auto(34), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(34), [], None, true)]), Auto(155), Bind1(LogQuantifier(Exists, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(35), [], None, true)]), Auto(153), Bind1(Eq(false, [Var(Auto(35), [], None, true)], [Var(Auto(34), [], None, true)]), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(161), Bind1(LogOpN(And, [Var(Auto(160), [], None, true), Var(Auto(161), [], None, true)]), Auto(157), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(158), Bind1(LogQuantifier(Exists, [(Auto(62), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(62), [], None, true)]), Auto(151), Bind1(LogQuantifier(Exists, [(Auto(63), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "unappend", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("z"), [], None, true), Var(Auto(63), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(63), [], None, true)], [Var(Auto(62), [], None, true)]), Auto(159), Bind1(LogOpN(And, [Var(Auto(158), [], None, true), Var(Auto(159), [], None, true)]), Auto(156), Bind1(LogOpN(Or, [Var(Auto(156), [], None, true), Var(Auto(157), [], None, true)]), Auto(154), Bind1(LogOpN(And, [Var(Auto(154), [], None, true), Var(Auto(155), [], None, true)]), Auto(152), Bind1(LogOpN(And, [Var(Auto(152), [], None, true), Var(Auto(153), [], None, true)]), Auto(150), Bind1(LogOpN(And, [Var(Auto(150), [], None, true), Var(Auto(151), [], None, true)]), Auto(148), Bind1(LogOpN(And, [Var(Auto(148), [], None, true), Var(Auto(149), [], None, true)]), Auto(147), Return([Var(Auto(147), [], None, true)])))))))))), Auto(144), Return([Var(Auto(144), [], None, true)])))), Auto(141), Return([Var(Auto(141), [], None, true)])))))))), Auto(138), Return([Var(Auto(138), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))), Auto(132), Return([Var(Auto(132), [], None, true)]))


SMT: (exists ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__) (x_z UI_LinkedList__UI_T__)) (exists ((xn_34 UI_LinkedList__UI_T__)) (exists ((xn_35 UI_LinkedList__UI_T__)) (exists ((xn_62 UI_LinkedList__UI_T__)) (exists ((xn_63 UI_LinkedList__UI_T__)) (and (and (and (and (or (and (distinct x_x x_y) (= xn_63 xn_62)) (and (distinct xn_35 xn_34) (= x_x x_y))) (F_unappend____ x_y x_z xn_34)) (F_unappend____ x_x x_z xn_35)) (F_unappend____ x_y x_z xn_62)) (F_unappend____ x_x x_z xn_63)))))))
Got SAT for case [root]

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("xs"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("ys"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("zs"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("xs"), [], None, true)], [Var(Manual("ys"), [], None, true)]), Auto(18), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(LogNot(Var(Auto(26), [], None, true)), Auto(31), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(31), [], None, true)]), Auto(34), Return([Var(Auto(34), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("xs"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("ys"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("zs"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("xs"), [], None, true)], [Var(Manual("ys"), [], None, true)]), Auto(18), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(LogNot(Var(Auto(26), [], None, true)), Auto(31), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(31), [], None, true)]), Auto(34), Return([Var(Auto(34), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(22), [], None, true)]), Auto(50), Bind1(LogNot(Var(Auto(50), [], None, true)), Auto(45), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(45), [], None, true)]), Auto(48), Return([Var(Auto(48), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(22), [], None, true)]), Auto(50), Bind1(LogNot(Var(Auto(50), [], None, true)), Auto(45), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(45), [], None, true)]), Auto(48), Return([Var(Auto(48), [], None, true)])))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(23), [], None, true)]), Auto(63), Bind1(LogNot(Var(Auto(63), [], None, true)), Auto(58), Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(51), [], None, true)]), Auto(48), Bind1(LogOpN(Or, [Var(Auto(48), [], None, true), Var(Auto(58), [], None, true)]), Auto(61), Return([Var(Auto(61), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(23), [], None, true)]), Auto(63), Bind1(LogNot(Var(Auto(63), [], None, true)), Auto(58), Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(51), [], None, true)]), Auto(48), Bind1(LogOpN(Or, [Var(Auto(48), [], None, true), Var(Auto(58), [], None, true)]), Auto(61), Return([Var(Auto(61), [], None, true)])))))))
Checking 1 cases...

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("xs"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("ys"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("zs"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("xs"), [], None, true)], [Var(Manual("ys"), [], None, true)]), Auto(18), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(22), [], None, true)]), Auto(51), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(23), [], None, true)]), Auto(64), Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(51), [], None, true)]), Auto(48), Bind1(LogOpN(Or, [Var(Auto(48), [], None, true), Var(Auto(64), [], None, true)]), Auto(61), Return([Var(Auto(61), [], None, true)]))))))), Auto(62), Return([Var(Auto(62), [], None, true)])))), Auto(49), Return([Var(Auto(49), [], None, true)])))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(66), Return([Var(Auto(66), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("xs"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("ys"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("zs"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("xs"), [], None, true)], [Var(Manual("ys"), [], None, true)]), Auto(18), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(22), [], None, true)]), Auto(51), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(23), [], None, true)]), Auto(64), Bind1(Eq(false, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(38), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(38), [], None, true)]), Auto(34), Bind1(LogOpN(Or, [Var(Auto(34), [], None, true), Var(Auto(51), [], None, true)]), Auto(48), Bind1(LogOpN(Or, [Var(Auto(48), [], None, true), Var(Auto(64), [], None, true)]), Auto(61), Return([Var(Auto(61), [], None, true)]))))))), Auto(62), Return([Var(Auto(62), [], None, true)])))), Auto(49), Return([Var(Auto(49), [], None, true)])))), Auto(0), Bind1(LogNot(Var(Auto(0), [], None, true)), Auto(66), Return([Var(Auto(66), [], None, true)])))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("LinkedList", [Base(UI("T", []))]), UI("T", [])}, ops: {OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "data", types: [], path: None }, OpCode { ident: "append", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }, OpCode { ident: "next", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }} }

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(14))], BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(24), Bind1(LogNot(Var(Auto(24), [], None, true)), Auto(29), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(47), Bind1(LogNot(Var(Auto(47), [], None, true)), Auto(42), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(15))], Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(42), [], None, true)]), Auto(45), Return([Var(Auto(45), [], None, true)]))))))))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(59), Bind1(LogNot(Var(Auto(59), [], None, true)), Auto(54), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(54), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)]))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(5), Bind1(LogOpN(Or, [Var(Auto(5), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)])))))), Auto(0), Return([Var(Auto(0), [], None, true)]))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("a"), [], None, true)]), [Atom(Auto(3))], Return([Literal(LogTrue)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(14), Bind1(LogNot(Var(Auto(14), [], None, true)), Auto(9), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(9), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)]))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(26))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Return([Var(Auto(25), [], None, true)]))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(49), Bind1(LogNot(Var(Auto(49), [], None, true)), Auto(44), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(27))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(44), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(57), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(27), [], None, true)]), [Atom(Auto(28))], Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(57), [], None, true)]), Auto(60), Return([Var(Auto(60), [], None, true)]))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)])))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(74), Bind1(LogNot(Var(Auto(74), [], None, true)), Auto(69), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(35))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(69), [], None, true)]), Auto(72), Return([Var(Auto(72), [], None, true)]))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(87), Bind1(LogNot(Var(Auto(87), [], None, true)), Auto(82), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(36))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(82), [], None, true)]), Auto(85), Return([Var(Auto(85), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(100), Bind1(LogNot(Var(Auto(100), [], None, true)), Auto(95), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(36), [], None, true)]), [Atom(Auto(37))], Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(95), [], None, true)]), Auto(98), Return([Var(Auto(98), [], None, true)])))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(6), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(32), Bind1(LogOpN(And, [Var(Auto(32), [], None, true), Var(Auto(6), [], None, true)]), Auto(9), Bind1(LogNot(Var(Auto(9), [], None, true)), Auto(37), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(37), [], None, true)]), Auto(40), Return([Var(Auto(40), [], None, true)])))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(58), Bind1(LogNot(Var(Auto(58), [], None, true)), Auto(53), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Return([Var(Auto(56), [], None, true)]))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(71), Bind1(LogNot(Var(Auto(71), [], None, true)), Auto(66), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(66), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)]))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(9))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Auto(9), [], None, true)]), [Atom(Auto(10))], Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(34), Bind1(LogNot(Var(Auto(34), [], None, true)), Auto(29), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(29), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)]))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)])))))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(60))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Return([Var(Auto(64), [], None, true)]))))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(68))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(true, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(79), Bind1(LogNot(Var(Auto(79), [], None, true)), Auto(84), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(84), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(10), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(102), Bind1(LogOpN(And, [Var(Auto(102), [], None, true), Var(Auto(10), [], None, true)]), Auto(13), Bind1(LogNot(Var(Auto(13), [], None, true)), Auto(107), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Return([Var(Auto(47), [], None, true)]))))))))))))))))))))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(129), Bind1(LogNot(Var(Auto(129), [], None, true)), Auto(124), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Auto(60), [], None, true)]), [Atom(Auto(61))], Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(124), [], None, true)]), Auto(127), Return([Var(Auto(127), [], None, true)]))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(141), Bind1(LogNot(Var(Auto(141), [], None, true)), Auto(136), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(136), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)]))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)])))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(153), Bind1(LogNot(Var(Auto(153), [], None, true)), Auto(148), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(69))], Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(148), [], None, true)]), Auto(151), Return([Var(Auto(151), [], None, true)]))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)]))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(165), Bind1(LogNot(Var(Auto(165), [], None, true)), Auto(160), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(76))], Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(160), [], None, true)]), Auto(163), Return([Var(Auto(163), [], None, true)])))))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)]))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(178), Bind1(LogNot(Var(Auto(178), [], None, true)), Auto(173), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(91))], Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(173), [], None, true)]), Auto(176), Return([Var(Auto(176), [], None, true)])))))))))))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(191), Bind1(LogNot(Var(Auto(191), [], None, true)), Auto(186), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(98))], Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(186), [], None, true)]), Auto(189), Return([Var(Auto(189), [], None, true)])))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)])))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(203), Bind1(LogNot(Var(Auto(203), [], None, true)), Auto(198), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(99))], Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(198), [], None, true)]), Auto(201), Return([Var(Auto(201), [], None, true)]))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(215), Bind1(LogNot(Var(Auto(215), [], None, true)), Auto(210), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(210), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)])))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(50))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(62), Bind1(LogNot(Var(Auto(62), [], None, true)), Auto(67), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(67), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(true, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(14), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(true, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(86), Bind1(LogOpN(And, [Var(Auto(86), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Bind1(LogNot(Var(Auto(17), [], None, true)), Auto(91), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(91), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Return([Var(Auto(49), [], None, true)]))))))))))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(112), Bind1(LogNot(Var(Auto(112), [], None, true)), Auto(107), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(51))], Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(107), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)])))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(124), Bind1(LogNot(Var(Auto(124), [], None, true)), Auto(119), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(52))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(119), [], None, true)]), Auto(122), Return([Var(Auto(122), [], None, true)]))))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(136), Bind1(LogNot(Var(Auto(136), [], None, true)), Auto(131), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(53))], Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(131), [], None, true)]), Auto(134), Return([Var(Auto(134), [], None, true)])))))))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)]))))))))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(148), Bind1(LogNot(Var(Auto(148), [], None, true)), Auto(143), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(80))], BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(143), [], None, true)]), Auto(146), Return([Var(Auto(146), [], None, true)])))))))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(160), Bind1(LogNot(Var(Auto(160), [], None, true)), Auto(155), BindN(Call(OpCode { ident: "data", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(81))], Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(155), [], None, true)]), Auto(158), Return([Var(Auto(158), [], None, true)]))))))))))))))))
Expanding call data...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)])))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(172), Bind1(LogNot(Var(Auto(172), [], None, true)), Auto(167), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("y"), [], None, true)]), [Atom(Auto(82))], BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(167), [], None, true)]), Auto(170), Return([Var(Auto(170), [], None, true)]))))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(184), Bind1(LogNot(Var(Auto(184), [], None, true)), Auto(179), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("x"), [], None, true)]), [Atom(Auto(83))], Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(179), [], None, true)]), Auto(182), Return([Var(Auto(182), [], None, true)])))))))))))))))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(196), Bind1(LogNot(Var(Auto(196), [], None, true)), Auto(191), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(191), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)])))))))))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(7))], Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Return([Var(Auto(10), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(25), Bind1(LogNot(Var(Auto(25), [], None, true)), Auto(20), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(20), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)])))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "chop", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call chop...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(16))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(true, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(20), Bind1(LogNot(Var(Auto(20), [], None, true)), Auto(25), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(25), [], None, true)]), Auto(28), Return([Var(Auto(28), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(44), Bind1(LogNot(Var(Auto(44), [], None, true)), Auto(39), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true)]), [Atom(Auto(17))], Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(39), [], None, true)]), Auto(42), Return([Var(Auto(42), [], None, true)])))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(57), Bind1(LogNot(Var(Auto(57), [], None, true)), Auto(52), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(52), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)])))))))

partial_eval returning [(CaseName([]), BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)]))))]

Adding recursion guards for {}
After match elimination: BindN(Call(OpCode { ident: "next", types: [], path: None }, [Var(Manual("NIL"), [], None, true)]), [Atom(Auto(5))], Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Return([Var(Auto(8), [], None, true)])))
Expanding call next...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(22), Bind1(LogNot(Var(Auto(22), [], None, true)), Auto(17), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(17), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)])))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(19))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Return([Var(Auto(26), [], None, true)])))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(41), Bind1(LogNot(Var(Auto(41), [], None, true)), Auto(36), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true)]), [Atom(Auto(20))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(36), [], None, true)]), Auto(39), Return([Var(Auto(39), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(54), Bind1(LogNot(Var(Auto(54), [], None, true)), Auto(49), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(21))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(49), [], None, true)]), Auto(52), Return([Var(Auto(52), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(67), Bind1(LogNot(Var(Auto(67), [], None, true)), Auto(62), BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true)]), [Atom(Auto(22))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(62), [], None, true)]), Auto(65), Return([Var(Auto(65), [], None, true)])))))))))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogNot(Var(Auto(80), [], None, true)), Auto(75), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true)]), [Atom(Auto(23))], Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Return([Var(Auto(78), [], None, true)])))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(93), Bind1(LogNot(Var(Auto(93), [], None, true)), Auto(88), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(88), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)])))))))))

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], BindN(Call(OpCode { ident: "cons", types: [], path: None }, [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true)]), [Atom(Auto(37))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(48), Bind1(LogNot(Var(Auto(48), [], None, true)), Auto(53), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(53), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(true, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(70), Bind1(LogNot(Var(Auto(70), [], None, true)), Auto(75), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(75), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Return([Var(Auto(36), [], None, true)])))))))))))))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Expanding call cons...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(95), Bind1(LogNot(Var(Auto(95), [], None, true)), Auto(90), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(38))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(90), [], None, true)]), Auto(93), Return([Var(Auto(93), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(108), Bind1(LogNot(Var(Auto(108), [], None, true)), Auto(103), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(39))], Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(103), [], None, true)]), Auto(106), Return([Var(Auto(106), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)]))))))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(121), Bind1(LogNot(Var(Auto(121), [], None, true)), Auto(116), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(66))], BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(116), [], None, true)]), Auto(119), Return([Var(Auto(119), [], None, true)])))))))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(134), Bind1(LogNot(Var(Auto(134), [], None, true)), Auto(129), BindN(Call(OpCode { ident: "append", types: [], path: None }, [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true)]), [Atom(Auto(67))], Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(129), [], None, true)]), Auto(132), Return([Var(Auto(132), [], None, true)])))))))))))
Expanding call append...

partial_eval returning [(CaseName([]), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))))]

Adding recursion guards for {}
After match elimination: Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(147), Bind1(LogNot(Var(Auto(147), [], None, true)), Auto(142), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(142), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)])))))))))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
axiom: Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))
Got relevant: Relevant { base_types: {UI("T", []), UI("LinkedList", [Base(UI("T", []))])}, ops: {OpCode { ident: "next", types: [], path: None }, OpCode { ident: "data", types: [], path: None }, OpCode { ident: "cons", types: [], path: None }, OpCode { ident: "chop", types: [], path: None }, OpCode { ident: "append", types: [], path: None }, OpCode { ident: "NIL", types: [], path: None }} }
Declared T as UI_T
Declared LinkedList<T> as UI_LinkedList__UI_T__
###
### Declaring op OpCode { ident: "next", types: [], path: None } to smt solver...
###

Declared next as absrel F_next____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for next]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_next____ xn_0 xn_4)) (not (F_next____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "data", types: [], path: None } to smt solver...
###

Declared data as absrel F_data____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for data]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_T)) (forall ((xn_4 UI_T)) (or (= xn_2 xn_4) (or (not (F_data____ xn_0 xn_4)) (not (F_data____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "cons", types: [], path: None } to smt solver...
###

Declared cons as absrel F_cons____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("T", []))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for cons]: (forall ((xn_0 UI_T) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_cons____ xn_0 xn_1 xn_5)) (not (F_cons____ xn_0 xn_1 xn_3)))))))
###
### Declaring op OpCode { ident: "chop", types: [], path: None } to smt solver...
###

Declared chop as absrel F_chop____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(17), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(18), Bind1(LogOpN(And, [Var(Auto(18), [], None, true), Var(Auto(17), [], None, true)]), Auto(11), Bind1(LogNot(Var(Auto(11), [], None, true)), Auto(13), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(13), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)])))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(2), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(4), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(2), [], None, true)]), Auto(21), Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(4), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(21), [], None, true)]), Auto(19), Bind1(Eq(true, [Var(Auto(2), [], None, true)], [Var(Auto(4), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(19), [], None, true)]), Auto(16), Return([Var(Auto(16), [], None, true)]))))))), Auto(5), Return([Var(Auto(5), [], None, true)]))), Auto(3), Return([Var(Auto(3), [], None, true)]))), Auto(1), Return([Var(Auto(1), [], None, true)]))


SMT Axiom [Rel-Fun for chop]: (forall ((xn_0 UI_LinkedList__UI_T__)) (forall ((xn_2 UI_LinkedList__UI_T__)) (forall ((xn_4 UI_LinkedList__UI_T__)) (or (= xn_2 xn_4) (or (not (F_chop____ xn_0 xn_4)) (not (F_chop____ xn_0 xn_2)))))))
###
### Declaring op OpCode { ident: "append", types: [], path: None } to smt solver...
###

Declared append as absrel F_append____

partial_eval returning [(CaseName([]), Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)])))]

Adding recursion guards for {}
After match elimination: Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(18), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(19), Bind1(LogOpN(And, [Var(Auto(19), [], None, true), Var(Auto(18), [], None, true)]), Auto(12), Bind1(LogNot(Var(Auto(12), [], None, true)), Auto(14), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(14), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)])))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(0), Base(UI("LinkedList", [Base(UI("T", []))]))), (Auto(1), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(3), [], None, true)]), Auto(22), Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(0), [], None, true), Var(Auto(1), [], None, true), Var(Auto(5), [], None, true)]), Auto(21), Bind1(LogOpN(Or, [Var(Auto(21), [], None, true), Var(Auto(22), [], None, true)]), Auto(20), Bind1(Eq(true, [Var(Auto(3), [], None, true)], [Var(Auto(5), [], None, true)]), Auto(9), Bind1(LogOpN(Or, [Var(Auto(9), [], None, true), Var(Auto(20), [], None, true)]), Auto(17), Return([Var(Auto(17), [], None, true)]))))))), Auto(6), Return([Var(Auto(6), [], None, true)]))), Auto(4), Return([Var(Auto(4), [], None, true)]))), Auto(2), Return([Var(Auto(2), [], None, true)]))


SMT Axiom [Rel-Fun for append]: (forall ((xn_0 UI_LinkedList__UI_T__) (xn_1 UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_3 xn_5) (or (not (F_append____ xn_0 xn_1 xn_5)) (not (F_append____ xn_0 xn_1 xn_3)))))))
Declared NIL as constant F_NIL____


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(14), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(14), [], None, true)]), Auto(48), Bind1(LogQuantifier(Forall, [(Auto(15), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(15), [], None, true)]), Auto(60), Bind1(Eq(true, [Var(Auto(15), [], None, true)], [Var(Auto(14), [], None, true)]), Auto(18), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(18), [], None, true), Var(Auto(36), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(32), [], None, true), Var(Auto(48), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(60), [], None, true)]), Auto(57), Return([Var(Auto(57), [], None, true)])))))))), Auto(58), Return([Var(Auto(58), [], None, true)])))), Auto(46), Return([Var(Auto(46), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_14 UI_LinkedList__UI_T__)) (forall ((xn_15 UI_LinkedList__UI_T__)) (or (or (or (= xn_15 xn_14) (distinct x_x x_y)) (not (F_chop____ x_y xn_14))) (not (F_chop____ x_x xn_15))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("b"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(14), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(24), Bind1(LogOpN(Or, [Var(Auto(24), [], None, true), Var(Auto(14), [], None, true)]), Auto(11), Return([Var(Auto(11), [], None, true)]))))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__) (x_b UI_LinkedList__UI_T__)) (or (distinct x_a x_b) (= x_a x_b)))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_LinkedList__UI_T__)) (or true (not (F_next____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(3), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Auto(3), [], None, true)]), Auto(15), Bind1(LogOpN(Or, [Literal(LogTrue), Var(Auto(15), [], None, true)]), Auto(12), Return([Var(Auto(12), [], None, true)])))), Auto(13), Return([Var(Auto(13), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_LinkedList__UI_T__)) (forall ((xn_3 UI_T)) (or true (not (F_data____ x_a xn_3)))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(26), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(26), [], None, true)]), Auto(50), Bind1(LogQuantifier(Forall, [(Auto(27), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(26), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(27), [], None, true)]), Auto(63), Bind1(LogQuantifier(Forall, [(Auto(28), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(27), [], None, true), Var(Auto(28), [], None, true)]), Auto(75), Bind1(Eq(true, [Var(Auto(28), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(31), Bind1(LogQuantifier(Forall, [(Auto(35), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(35), [], None, true)]), Auto(88), Bind1(LogQuantifier(Forall, [(Auto(36), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(35), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(36), [], None, true)]), Auto(101), Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(36), [], None, true), Var(Auto(37), [], None, true)]), Auto(113), Bind1(Eq(true, [Var(Auto(37), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(11), Bind1(LogOpN(And, [Var(Auto(11), [], None, true), Var(Auto(31), [], None, true)]), Auto(25), Bind1(LogOpN(Or, [Var(Auto(25), [], None, true), Var(Auto(50), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(63), [], None, true)]), Auto(60), Bind1(LogOpN(Or, [Var(Auto(60), [], None, true), Var(Auto(75), [], None, true)]), Auto(72), Bind1(LogOpN(Or, [Var(Auto(72), [], None, true), Var(Auto(88), [], None, true)]), Auto(85), Bind1(LogOpN(Or, [Var(Auto(85), [], None, true), Var(Auto(101), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(98), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Return([Var(Auto(110), [], None, true)]))))))))))), Auto(111), Return([Var(Auto(111), [], None, true)])))), Auto(99), Return([Var(Auto(99), [], None, true)])))), Auto(86), Return([Var(Auto(86), [], None, true)]))))), Auto(73), Return([Var(Auto(73), [], None, true)])))), Auto(61), Return([Var(Auto(61), [], None, true)])))), Auto(48), Return([Var(Auto(48), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_y UI_LinkedList__UI_T__)) (forall ((xn_26 UI_LinkedList__UI_T__)) (forall ((xn_27 UI_LinkedList__UI_T__)) (forall ((xn_28 UI_LinkedList__UI_T__)) (forall ((xn_35 UI_LinkedList__UI_T__)) (forall ((xn_36 UI_LinkedList__UI_T__)) (forall ((xn_37 UI_T)) (or (or (or (or (or (or (and (= xn_37 x_a) (= xn_28 x_y)) (not (F_cons____ x_a F_NIL____ xn_26))) (not (F_append____ xn_26 x_y xn_27))) (not (F_next____ xn_27 xn_28))) (not (F_cons____ x_a F_NIL____ xn_35))) (not (F_append____ xn_35 x_y xn_36))) (not (F_data____ xn_36 xn_37))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(59), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(23), [], None, true)]), Auto(72), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(26), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(46), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(45), Bind1(LogOpN(Or, [Var(Auto(45), [], None, true), Var(Auto(46), [], None, true)]), Auto(44), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(44), [], None, true)]), Auto(40), Bind1(LogOpN(Or, [Var(Auto(40), [], None, true), Var(Auto(59), [], None, true)]), Auto(56), Bind1(LogOpN(Or, [Var(Auto(56), [], None, true), Var(Auto(72), [], None, true)]), Auto(69), Return([Var(Auto(69), [], None, true)])))))))))), Auto(70), Return([Var(Auto(70), [], None, true)])))), Auto(57), Return([Var(Auto(57), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_b UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (= xn_23 xn_22) (or (distinct x_x x_y) (distinct x_a x_b))) (not (F_cons____ x_b x_y xn_22))) (not (F_cons____ x_a x_x xn_23))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(9), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(9), [], None, true)]), Auto(23), Bind1(LogQuantifier(Forall, [(Auto(10), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Auto(9), [], None, true), Var(Auto(10), [], None, true)]), Auto(35), Bind1(Eq(true, [Var(Auto(10), [], None, true)], [Var(Manual("a"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Bind1(LogOpN(Or, [Var(Auto(20), [], None, true), Var(Auto(35), [], None, true)]), Auto(32), Return([Var(Auto(32), [], None, true)])))))), Auto(33), Return([Var(Auto(33), [], None, true)])))), Auto(21), Return([Var(Auto(21), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_9 UI_LinkedList__UI_T__)) (forall ((xn_10 UI_T)) (or (or (= xn_10 x_a) (not (F_cons____ x_a x_x xn_9))) (not (F_data____ xn_9 xn_10))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(60), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(60), [], None, true)]), Auto(130), Bind1(LogQuantifier(Forall, [(Auto(61), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Auto(60), [], None, true), Var(Auto(61), [], None, true)]), Auto(142), Bind1(Eq(true, [Var(Auto(61), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(64), Bind1(LogOpN(Or, [Var(Auto(64), [], None, true), Var(Auto(130), [], None, true)]), Auto(127), Bind1(LogOpN(Or, [Var(Auto(127), [], None, true), Var(Auto(142), [], None, true)]), Auto(139), Return([Var(Auto(139), [], None, true)])))))), Auto(140), Return([Var(Auto(140), [], None, true)])))), Auto(128), Return([Var(Auto(128), [], None, true)]))), Auto(48), Bind1(LogQuantifier(Forall, [(Manual("a"), Base(UI("T", []))), (Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(68), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(68), [], None, true)]), Auto(154), Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Auto(68), [], None, true)]), Auto(38), Bind1(LogQuantifier(Forall, [(Auto(69), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(69), [], None, true)]), Auto(166), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Auto(69), [], None, true)]), Auto(72), Bind1(LogOpN(And, [Var(Auto(72), [], None, true), Var(Auto(38), [], None, true)]), Auto(41), Bind1(LogQuantifier(Forall, [(Auto(76), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(76), [], None, true)]), Auto(179), Bind1(Eq(false, [Var(Auto(76), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(117), Bind1(LogOpN(Or, [Var(Auto(41), [], None, true), Var(Auto(117), [], None, true)]), Auto(87), Bind1(LogQuantifier(Forall, [(Auto(91), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(91), [], None, true)]), Auto(192), Bind1(Eq(true, [Var(Auto(91), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(94), Bind1(LogQuantifier(Forall, [(Auto(98), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(98), [], None, true)]), Auto(204), Bind1(Eq(false, [Var(Manual("a"), [], None, true)], [Var(Auto(98), [], None, true)]), Auto(116), Bind1(LogQuantifier(Forall, [(Auto(99), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(99), [], None, true)]), Auto(216), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Auto(99), [], None, true)]), Auto(115), Bind1(LogOpN(Or, [Var(Auto(115), [], None, true), Var(Auto(116), [], None, true)]), Auto(114), Bind1(LogOpN(Or, [Var(Auto(94), [], None, true), Var(Auto(114), [], None, true)]), Auto(110), Bind1(LogOpN(And, [Var(Auto(110), [], None, true), Var(Auto(87), [], None, true)]), Auto(47), Bind1(LogOpN(Or, [Var(Auto(47), [], None, true), Var(Auto(154), [], None, true)]), Auto(151), Bind1(LogOpN(Or, [Var(Auto(151), [], None, true), Var(Auto(166), [], None, true)]), Auto(163), Bind1(LogOpN(Or, [Var(Auto(163), [], None, true), Var(Auto(179), [], None, true)]), Auto(176), Bind1(LogOpN(Or, [Var(Auto(176), [], None, true), Var(Auto(192), [], None, true)]), Auto(189), Bind1(LogOpN(Or, [Var(Auto(189), [], None, true), Var(Auto(204), [], None, true)]), Auto(201), Bind1(LogOpN(Or, [Var(Auto(201), [], None, true), Var(Auto(216), [], None, true)]), Auto(213), Return([Var(Auto(213), [], None, true)]))))))))))))), Auto(214), Return([Var(Auto(214), [], None, true)]))))), Auto(202), Return([Var(Auto(202), [], None, true)]))))), Auto(190), Return([Var(Auto(190), [], None, true)])))))), Auto(177), Return([Var(Auto(177), [], None, true)])))))), Auto(164), Return([Var(Auto(164), [], None, true)]))))), Auto(152), Return([Var(Auto(152), [], None, true)]))), Auto(0), Bind1(LogOpN(And, [Var(Auto(0), [], None, true), Var(Auto(48), [], None, true)]), Auto(59), Return([Var(Auto(59), [], None, true)]))))


SMT Axiom: (and (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_68 UI_T)) (forall ((xn_69 UI_LinkedList__UI_T__)) (forall ((xn_76 UI_LinkedList__UI_T__)) (forall ((xn_91 UI_LinkedList__UI_T__)) (forall ((xn_98 UI_T)) (forall ((xn_99 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (and (or (= xn_91 x_y) (or (distinct x_x xn_99) (distinct x_a xn_98))) (or (and (= x_x xn_69) (= x_a xn_68)) (distinct xn_76 x_y))) (not (F_data____ x_y xn_68))) (not (F_next____ x_y xn_69))) (not (F_cons____ x_a x_x xn_76))) (not (F_cons____ x_a x_x xn_91))) (not (F_data____ x_y xn_98))) (not (F_next____ x_y xn_99)))))))))) (forall ((x_a UI_T) (x_x UI_LinkedList__UI_T__)) (forall ((xn_60 UI_LinkedList__UI_T__)) (forall ((xn_61 UI_LinkedList__UI_T__)) (or (or (= xn_61 x_x) (not (F_cons____ x_a x_x xn_60))) (not (F_next____ xn_60 xn_61)))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(50), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(50), [], None, true)]), Auto(113), Bind1(LogQuantifier(Forall, [(Auto(51), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(51), [], None, true)]), Auto(125), Bind1(Eq(true, [Var(Auto(50), [], None, true)], [Var(Auto(51), [], None, true)]), Auto(40), Bind1(LogQuantifier(Forall, [(Auto(52), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(52), [], None, true)]), Auto(137), Bind1(LogQuantifier(Forall, [(Auto(53), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(53), [], None, true)]), Auto(149), Bind1(Eq(true, [Var(Auto(53), [], None, true)], [Var(Auto(52), [], None, true)]), Auto(56), Bind1(LogOpN(And, [Var(Auto(56), [], None, true), Var(Auto(40), [], None, true)]), Auto(43), Bind1(Eq(false, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(101), Bind1(LogOpN(Or, [Var(Auto(43), [], None, true), Var(Auto(101), [], None, true)]), Auto(70), Bind1(Eq(true, [Var(Manual("x"), [], None, true)], [Var(Manual("y"), [], None, true)]), Auto(76), Bind1(LogQuantifier(Forall, [(Auto(80), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(80), [], None, true)]), Auto(161), Bind1(LogQuantifier(Forall, [(Auto(81), Base(UI("T", [])))], Bind1(LogOpN(Pred(OpCode { ident: "data", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(81), [], None, true)]), Auto(173), Bind1(Eq(false, [Var(Auto(80), [], None, true)], [Var(Auto(81), [], None, true)]), Auto(100), Bind1(LogQuantifier(Forall, [(Auto(82), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("y"), [], None, true), Var(Auto(82), [], None, true)]), Auto(185), Bind1(LogQuantifier(Forall, [(Auto(83), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(83), [], None, true)]), Auto(197), Bind1(Eq(false, [Var(Auto(83), [], None, true)], [Var(Auto(82), [], None, true)]), Auto(99), Bind1(LogOpN(Or, [Var(Auto(99), [], None, true), Var(Auto(100), [], None, true)]), Auto(98), Bind1(LogOpN(Or, [Var(Auto(76), [], None, true), Var(Auto(98), [], None, true)]), Auto(94), Bind1(LogOpN(And, [Var(Auto(94), [], None, true), Var(Auto(70), [], None, true)]), Auto(49), Bind1(LogOpN(Or, [Var(Auto(49), [], None, true), Var(Auto(113), [], None, true)]), Auto(110), Bind1(LogOpN(Or, [Var(Auto(110), [], None, true), Var(Auto(125), [], None, true)]), Auto(122), Bind1(LogOpN(Or, [Var(Auto(122), [], None, true), Var(Auto(137), [], None, true)]), Auto(134), Bind1(LogOpN(Or, [Var(Auto(134), [], None, true), Var(Auto(149), [], None, true)]), Auto(146), Bind1(LogOpN(Or, [Var(Auto(146), [], None, true), Var(Auto(161), [], None, true)]), Auto(158), Bind1(LogOpN(Or, [Var(Auto(158), [], None, true), Var(Auto(173), [], None, true)]), Auto(170), Bind1(LogOpN(Or, [Var(Auto(170), [], None, true), Var(Auto(185), [], None, true)]), Auto(182), Bind1(LogOpN(Or, [Var(Auto(182), [], None, true), Var(Auto(197), [], None, true)]), Auto(194), Return([Var(Auto(194), [], None, true)]))))))))))))))), Auto(195), Return([Var(Auto(195), [], None, true)])))), Auto(183), Return([Var(Auto(183), [], None, true)]))))), Auto(171), Return([Var(Auto(171), [], None, true)])))), Auto(159), Return([Var(Auto(159), [], None, true)]))))))))), Auto(147), Return([Var(Auto(147), [], None, true)])))), Auto(135), Return([Var(Auto(135), [], None, true)]))))), Auto(123), Return([Var(Auto(123), [], None, true)])))), Auto(111), Return([Var(Auto(111), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__)) (forall ((xn_50 UI_T)) (forall ((xn_51 UI_T)) (forall ((xn_52 UI_LinkedList__UI_T__)) (forall ((xn_53 UI_LinkedList__UI_T__)) (forall ((xn_80 UI_T)) (forall ((xn_81 UI_T)) (forall ((xn_82 UI_LinkedList__UI_T__)) (forall ((xn_83 UI_LinkedList__UI_T__)) (or (or (or (or (or (or (or (or (and (or (= x_x x_y) (or (distinct xn_83 xn_82) (distinct xn_80 xn_81))) (or (and (= xn_53 xn_52) (= xn_50 xn_51)) (distinct x_x x_y))) (not (F_data____ x_x xn_50))) (not (F_data____ x_y xn_51))) (not (F_next____ x_y xn_52))) (not (F_next____ x_x xn_53))) (not (F_data____ x_x xn_80))) (not (F_data____ x_y xn_81))) (not (F_next____ x_y xn_82))) (not (F_next____ x_x xn_83))))))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogQuantifier(Forall, [(Auto(7), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(7), [], None, true)]), Auto(26), Bind1(Eq(true, [Var(Auto(7), [], None, true)], [Var(Manual("x"), [], None, true)]), Auto(10), Bind1(LogOpN(Or, [Var(Auto(10), [], None, true), Var(Auto(26), [], None, true)]), Auto(23), Return([Var(Auto(23), [], None, true)]))))), Auto(24), Return([Var(Auto(24), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__)) (forall ((xn_7 UI_LinkedList__UI_T__)) (or (= xn_7 x_x) (not (F_append____ x_x F_NIL____ xn_7)))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "chop", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_chop____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("a"), Base(UI("T", []))), (Manual("b"), Base(UI("T", [])))], Bind1(Eq(true, [Var(Manual("a"), [], None, true)], [Var(Manual("b"), [], None, true)]), Auto(12), Bind1(LogQuantifier(Forall, [(Auto(16), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("b"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(16), [], None, true)]), Auto(45), Bind1(LogQuantifier(Forall, [(Auto(17), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("a"), [], None, true), Var(Manual("x"), [], None, true), Var(Auto(17), [], None, true)]), Auto(58), Bind1(Eq(false, [Var(Auto(17), [], None, true)], [Var(Auto(16), [], None, true)]), Auto(32), Bind1(LogOpN(Or, [Var(Auto(12), [], None, true), Var(Auto(32), [], None, true)]), Auto(28), Bind1(LogOpN(Or, [Var(Auto(28), [], None, true), Var(Auto(45), [], None, true)]), Auto(42), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(58), [], None, true)]), Auto(55), Return([Var(Auto(55), [], None, true)]))))))), Auto(56), Return([Var(Auto(56), [], None, true)])))), Auto(43), Return([Var(Auto(43), [], None, true)])))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_a UI_T) (x_b UI_T)) (forall ((xn_16 UI_LinkedList__UI_T__)) (forall ((xn_17 UI_LinkedList__UI_T__)) (or (or (or (= x_a x_b) (distinct xn_17 xn_16)) (not (F_cons____ x_b x_x xn_16))) (not (F_cons____ x_a x_x xn_17))))))


Called smt on Bind1(LogQuantifier(Forall, [(Auto(5), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "next", types: [], path: None }, false), [Var(Manual("NIL"), [], None, true), Var(Auto(5), [], None, true)]), Auto(23), Bind1(Eq(true, [Var(Auto(5), [], None, true)], [Var(Manual("NIL"), [], None, true)]), Auto(8), Bind1(LogOpN(Or, [Var(Auto(8), [], None, true), Var(Auto(23), [], None, true)]), Auto(20), Return([Var(Auto(20), [], None, true)]))))), Auto(21), Return([Var(Auto(21), [], None, true)]))


SMT Axiom: (forall ((xn_5 UI_LinkedList__UI_T__)) (or (= xn_5 F_NIL____) (not (F_next____ F_NIL____ xn_5))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("x"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("y"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(19), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(19), [], None, true)]), Auto(42), Bind1(LogQuantifier(Forall, [(Auto(20), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(19), [], None, true), Var(Auto(20), [], None, true)]), Auto(55), Bind1(LogQuantifier(Forall, [(Auto(21), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Auto(20), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(21), [], None, true)]), Auto(68), Bind1(LogQuantifier(Forall, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("y"), [], None, true), Var(Auto(22), [], None, true)]), Auto(81), Bind1(LogQuantifier(Forall, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("x"), [], None, true), Var(Auto(22), [], None, true), Var(Auto(23), [], None, true)]), Auto(94), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(21), [], None, true)]), Auto(26), Bind1(LogOpN(Or, [Var(Auto(26), [], None, true), Var(Auto(42), [], None, true)]), Auto(39), Bind1(LogOpN(Or, [Var(Auto(39), [], None, true), Var(Auto(55), [], None, true)]), Auto(52), Bind1(LogOpN(Or, [Var(Auto(52), [], None, true), Var(Auto(68), [], None, true)]), Auto(65), Bind1(LogOpN(Or, [Var(Auto(65), [], None, true), Var(Auto(81), [], None, true)]), Auto(78), Bind1(LogOpN(Or, [Var(Auto(78), [], None, true), Var(Auto(94), [], None, true)]), Auto(91), Return([Var(Auto(91), [], None, true)]))))))))), Auto(92), Return([Var(Auto(92), [], None, true)])))), Auto(79), Return([Var(Auto(79), [], None, true)])))), Auto(66), Return([Var(Auto(66), [], None, true)])))), Auto(53), Return([Var(Auto(53), [], None, true)])))), Auto(40), Return([Var(Auto(40), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_x UI_LinkedList__UI_T__) (x_y UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_19 UI_LinkedList__UI_T__)) (forall ((xn_20 UI_LinkedList__UI_T__)) (forall ((xn_21 UI_LinkedList__UI_T__)) (forall ((xn_22 UI_LinkedList__UI_T__)) (forall ((xn_23 UI_LinkedList__UI_T__)) (or (or (or (or (or (= xn_23 xn_21) (not (F_cons____ x_t F_NIL____ xn_19))) (not (F_append____ x_x xn_19 xn_20))) (not (F_append____ xn_20 x_y xn_21))) (not (F_cons____ x_t x_y xn_22))) (not (F_append____ x_x xn_22 xn_23)))))))))


Called smt on Bind1(LogQuantifier(Forall, [(Manual("l"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("r"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("t"), Base(UI("T", [])))], Bind1(LogQuantifier(Forall, [(Auto(37), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "cons", types: [], path: None }, false), [Var(Manual("t"), [], None, true), Var(Manual("NIL"), [], None, true), Var(Auto(37), [], None, true)]), Auto(96), Bind1(LogQuantifier(Forall, [(Auto(38), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(38), [], None, true)]), Auto(109), Bind1(LogQuantifier(Forall, [(Auto(39), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(39), [], None, true)]), Auto(122), Bind1(Eq(true, [Var(Auto(39), [], None, true)], [Var(Auto(38), [], None, true)]), Auto(42), Bind1(Eq(false, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(83), Bind1(LogOpN(Or, [Var(Auto(42), [], None, true), Var(Auto(83), [], None, true)]), Auto(56), Bind1(Eq(true, [Var(Manual("l"), [], None, true)], [Var(Manual("r"), [], None, true)]), Auto(62), Bind1(LogQuantifier(Forall, [(Auto(66), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("r"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(66), [], None, true)]), Auto(135), Bind1(LogQuantifier(Forall, [(Auto(67), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, false), [Var(Manual("l"), [], None, true), Var(Auto(37), [], None, true), Var(Auto(67), [], None, true)]), Auto(148), Bind1(Eq(false, [Var(Auto(67), [], None, true)], [Var(Auto(66), [], None, true)]), Auto(82), Bind1(LogOpN(Or, [Var(Auto(62), [], None, true), Var(Auto(82), [], None, true)]), Auto(78), Bind1(LogOpN(And, [Var(Auto(78), [], None, true), Var(Auto(56), [], None, true)]), Auto(36), Bind1(LogOpN(Or, [Var(Auto(36), [], None, true), Var(Auto(96), [], None, true)]), Auto(93), Bind1(LogOpN(Or, [Var(Auto(93), [], None, true), Var(Auto(109), [], None, true)]), Auto(106), Bind1(LogOpN(Or, [Var(Auto(106), [], None, true), Var(Auto(122), [], None, true)]), Auto(119), Bind1(LogOpN(Or, [Var(Auto(119), [], None, true), Var(Auto(135), [], None, true)]), Auto(132), Bind1(LogOpN(Or, [Var(Auto(132), [], None, true), Var(Auto(148), [], None, true)]), Auto(145), Return([Var(Auto(145), [], None, true)]))))))))))), Auto(146), Return([Var(Auto(146), [], None, true)])))), Auto(133), Return([Var(Auto(133), [], None, true)])))))))), Auto(120), Return([Var(Auto(120), [], None, true)])))), Auto(107), Return([Var(Auto(107), [], None, true)])))), Auto(94), Return([Var(Auto(94), [], None, true)]))), Auto(0), Return([Var(Auto(0), [], None, true)]))


SMT Axiom: (forall ((x_l UI_LinkedList__UI_T__) (x_r UI_LinkedList__UI_T__) (x_t UI_T)) (forall ((xn_37 UI_LinkedList__UI_T__)) (forall ((xn_38 UI_LinkedList__UI_T__)) (forall ((xn_39 UI_LinkedList__UI_T__)) (forall ((xn_66 UI_LinkedList__UI_T__)) (forall ((xn_67 UI_LinkedList__UI_T__)) (or (or (or (or (or (and (or (= x_l x_r) (distinct xn_67 xn_66)) (or (= xn_39 xn_38) (distinct x_l x_r))) (not (F_cons____ x_t F_NIL____ xn_37))) (not (F_append____ x_r xn_37 xn_38))) (not (F_append____ x_l xn_37 xn_39))) (not (F_append____ x_r xn_37 xn_66))) (not (F_append____ x_l xn_37 xn_67)))))))))


Called smt on Bind1(LogQuantifier(Exists, [(Manual("xs"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("ys"), Base(UI("LinkedList", [Base(UI("T", []))]))), (Manual("zs"), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(Eq(false, [Var(Manual("xs"), [], None, true)], [Var(Manual("ys"), [], None, true)]), Auto(79), Bind1(LogQuantifier(Exists, [(Auto(22), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("ys"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(22), [], None, true)]), Auto(78), Bind1(LogQuantifier(Exists, [(Auto(23), Base(UI("LinkedList", [Base(UI("T", []))])))], Bind1(LogOpN(Pred(OpCode { ident: "append", types: [], path: None }, true), [Var(Manual("xs"), [], None, true), Var(Manual("zs"), [], None, true), Var(Auto(23), [], None, true)]), Auto(76), Bind1(Eq(true, [Var(Auto(23), [], None, true)], [Var(Auto(22), [], None, true)]), Auto(80), Bind1(LogOpN(And, [Var(Auto(79), [], None, true), Var(Auto(80), [], None, true)]), Auto(77), Bind1(LogOpN(And, [Var(Auto(77), [], None, true), Var(Auto(78), [], None, true)]), Auto(75), Bind1(LogOpN(And, [Var(Auto(75), [], None, true), Var(Auto(76), [], None, true)]), Auto(74), Return([Var(Auto(74), [], None, true)]))))))), Auto(71), Return([Var(Auto(71), [], None, true)])))), Auto(68), Return([Var(Auto(68), [], None, true)])))), Auto(65), Return([Var(Auto(65), [], None, true)]))


SMT: (exists ((x_xs UI_LinkedList__UI_T__) (x_ys UI_LinkedList__UI_T__) (x_zs UI_LinkedList__UI_T__)) (exists ((xn_22 UI_LinkedList__UI_T__)) (exists ((xn_23 UI_LinkedList__UI_T__)) (and (and (and (distinct x_xs x_ys) (= xn_23 xn_22)) (F_append____ x_ys x_zs xn_22)) (F_append____ x_xs x_zs xn_23)))))
Got SAT for case [root]

thread 'p8::p8::ravencheck_tests::check_properties' (153865) panicked at /home/jorb/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ravencheck-0.4.1/src/rcc.rs:545:13:

#########[ verification failed ]#########
##
## > Failed to verify 'chop_append_relation': solver found counterexample
##
## > Failed to verify 'append_unappend_relation': solver found counterexample
##
## > Failed to verify 'unappend_eq': solver found counterexample
##
## > Failed to verify 'injectivity_of_append': solver found counterexample
##
#########################################

note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    p8::p8::ravencheck_tests::check_properties

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 45 filtered out; finished in 0.69s

