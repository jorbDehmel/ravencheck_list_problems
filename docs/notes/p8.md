
# Initial analysis

```
append(x, y):
  match x {
    LinkedList::Nil => y,
    LinkedList::Cons(z, xs) => LinkedList::Cons(z, Box::new(append(*xs, y)))
  }

// With no unrolling:
let a = match xs {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, tail) => LinkedList::Cons(z, Box::new(append(*tail, zs)))
};
let b = match ys {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, tail) => LinkedList::Cons(z, Box::new(append(*tail, zs)))
};
implies(
  a == b,
  xs == ys
)

// 1-step unrolling:
let a = match xs {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, xs_unroll) => LinkedList::Cons(z, Box::new(
    match xs_unroll {
      LinkedList::Nil => zs,
      LinkedList::Cons(z, xs_unroll_unroll) => LinkedList::Cons(z, Box::new(
        append(*xs_unroll_unroll, zs)
      ))
    }
  ))
};
let b = match ys {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, ys_unroll) => LinkedList::Cons(z, Box::new(
    match ys_unroll {
      LinkedList::Nil => zs,
      LinkedList::Cons(z, ys_unroll_unroll) => LinkedList::Cons(z, Box::new(
        append(*ys_unroll_unroll, zs)
      ))
    }
  ))
};
implies(
  a == b,
  xs == ys
)

// Input cases for computing a and b, where we assume it holds
// for the first unrolling.
```

# Initial decomposition

1. xs == ys == nil
  - Then a == zs, b == zs
  - Then a == b
  - QED

2. xs == Cons(z, xs_unroll), ys == nil (or vice versa WLOG)
  - Then b == zs
  - Then a == cons(z, append(xs_unroll, zs))
  - If xs_unroll == nil:
    - Then a == cons(z, zs)
    - a != b
    - QED
  - Else:
    - Then xs_unroll == cons(z2, xs_unroll2)
    - Then a == cons(z, cons(z2, append(xs_unroll2, zs)))
    - It seems clear to me that a != b, but why?
    - cons(z, cons(z2, append(xs_unroll2, zs))) != zs
      - What if we just assert this axiomatically?
      - Didn't fix it! This isn't the problem.

3. xs == Cons(z1, xs_unroll), ys == Cons(z2, ys_unroll)
  - Then a == cons(z1, append(xs_unroll, zs))
  - And  b == cons(z2, append(ys_unroll, zs))
  - If z1 != z2:
    - a != b
    - QED
  - Else:
    - By assumption, append(xs_unroll, zs) == append(ys_unroll, zs)
    - QED
  - QED

# Things I tried

Some variations on plugging a perceived hole (that didn't work).

```rust
#[assume]
fn foo() -> bool {
  forall(|root: LinkedList, to_append: LinkedList| {
    implies(
      root != LinkedList::Nil && to_append != LinkedList::Nil,
      append(root, to_append) != to_append
    )
  })
}

#[assume]
fn foo() -> bool {
  forall(|root: LinkedList, to_append: LinkedList| {
    implies(
      append(root, to_append) == to_append,
      root == LinkedList::Nil
    )
  })
}
```

From the following I learned that my assumption of where it's
getting confused is wrong.

```rust
#[assume]
fn foo() -> bool {
  forall(|z: T, z2: T, xs_unroll2: LinkedList, zs: LinkedList| {
    LinkedList::Cons(z, LinkedList::Cons(z2, append(xs_unroll2, zs))) != zs
  })
}
```

# Decomposition attempt 2

```rust
#[define]
#[recursive]
fn append(x: LinkedList, y: LinkedList) -> LinkedList {
  match x {
    LinkedList::Nil => y,
    LinkedList::Cons(z, xs) => LinkedList::Cons(z, Box::new(append(*xs, y)))
  }
}

#[annotate_multi]
#[for_values(xs: LinkedList, ys: LinkedList, zs: LinkedList)]
#[for_call(append(xs, zs) => a)]
#[for_call(append(ys, zs) => b)]
fn injectivity_of_append() -> bool {
  implies(
    a == b,
    xs == ys
  )
}

// Becomes
fn injectivity_of_append() -> bool {
  let a = append(xs, zs);
  let b = append(ys, zs);

  implies(
    a == b,
    xs == ys
  )
}

// Becomes
fn injectivity_of_append() -> bool {
  let a = match xs {
    LinkedList::Nil => zs,
    LinkedList::Cons(z, xs_inner) => LinkedList::Cons(z, Box::new(append(*xs_inner, zs)))
  };
  let b = match ys {
    LinkedList::Nil => zs,
    LinkedList::Cons(z, ys_inner) => LinkedList::Cons(z, Box::new(append(*ys_inner, zs)))
  };

  implies(
    a == b,
    xs == ys
  )
}
```

Assume $a == b$, EG that

```rust
match xs {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, xs_inner) => LinkedList::Cons(z, Box::new(append(*xs_inner, zs)))
} == match ys {
  LinkedList::Nil => zs,
  LinkedList::Cons(z, ys_inner) => LinkedList::Cons(z, Box::new(append(*ys_inner, zs)))
}
```

Assume a == b. WTS xs == ys.
(xs ++ zs) == (ys ++ zs) => (xs == ys)
Either:
1. xs == nil and ys == nil
  - Then, xs == ys
  - QED
2. xs == cons(z1, next1) and ys == cons(z2, next2)
  - In this case, we know that cons(z1, append(next1, zs)) == cons(z2, append(next2, zs))
  - By assumption, z1 == z2
  - We know that append(next1, zs) == append(next2, zs)
  - This is the inductive previous case
  - QED
3. xs == nil and ys == cons(z, next) or vice versa WLOG
  - First, note xs != ys. WTS a != b (contrapositive case).
  - Then, a == zs
  - Then, b == cons(z, append(next, zs))
  - WTS zs != cons(z, append(next, zs))
    - If not:
    - Then: zs must start with the same item as ys
    - cons(z, znext) == cons(z, append(next, cons(z, znext)))
    - z_next == append(y_next, cons(z, z_next))
    - Then it would have to recurse on the next step
    - Maybe it's a self-loop thing?
      - Consider when zs = ys^(omega)
      - Does it know lists can't have self-loops?

```rust
#[assume]
fn foo() -> bool {
  forall(|a: LinkedList, b: LinkedList, t: T| {
    implies(
      LinkedList::Cons(t, a) == LinkedList::Cons(t, b),
      a == b
    )
  })
}
```

At this point, I thought: "Does it know all lists must end?",
so I wrote the following to disallow loops. It did not work.

```rust
#[define]
#[recursive]
fn descendent(a: LinkedList, b: LinkedList) -> bool {
  match a {
    LinkedList::Nil => match b {
      LinkedList::Nil => true,
      LinkedList::Cons(_data, _next) => false
    },
    LinkedList::Cons(_data, next) => (b == *next) || descendent(*next, b)
  }
}

#[assume]
fn no_loops() -> bool {
  forall(|x: LinkedList| {
    !descendent(x, x)
  })
}
```

WTS xs != ys
Facts (for this case):
- append(xs, zs) == append(ys, zs)
- xs == nil and ys == cons(z, next)

- zs == append(cons(z, next), zs)
  - zs == cons(z, append(next, zs))
