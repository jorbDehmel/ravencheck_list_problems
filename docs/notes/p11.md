
This is the first problem which quantifies over functions. The
following is my naive implementation.

```rust
#[ravencheck::check_module]
#[allow(dead_code)]
mod p11 {
  #[import]
  use crate::list::linked_list::*;

  #[define]
  pub enum LinkedListOfLists {
    Nil,
    Cons(LinkedList, Box<LinkedListOfLists>),
  }

  #[define]
  #[recursive]
  fn map(f: fn(T) -> LinkedList, x: LinkedList) -> LinkedListOfLists {
    match x {
      LinkedList::Nil => LinkedListOfLists::Nil,
      LinkedList::Cons(y, xs) => LinkedListOfLists::Cons(f(y), Box::new(map(f, *xs)))
    }
  }

  #[define]
  #[recursive]
  fn right_right_equal(x: LinkedList, y: fn(T) -> LinkedList) -> LinkedList {
    match x {
      LinkedList::Nil => LinkedList::Nil,
      LinkedList::Cons(z, xs) => append(
        y(z),
        right_right_equal(*xs, y)
      )
    }
  }

  #[define]
  #[recursive]
  fn concat(x: LinkedListOfLists) -> LinkedList {
    match x {
      LinkedListOfLists::Nil => LinkedList::Nil,
      LinkedListOfLists::Cons(y, xs) => append(y, concat(*xs))
    }
  }

  #[annotate_multi]
  #[for_values(xs: LinkedList)]
  #[for_values(f: fn(T) -> LinkedList)]
  fn list_concat_map_bind() -> bool {
    concat(map(f, xs)) == right_right_equal(xs, f)
  }
}
```

After talking to Nick briefly, the following is how you're
supposed to do it.

```rust
#[declare]
#[phantom]
fn f(_: T) -> LinkedList {}

#[annotate_multi]
#[for_values(xs: LinkedList)]
fn list_concat_map_bind() -> bool {
  concat(map(f, xs)) == right_right_equal(xs, f)
}
```

Now I just need to make it actually verify.
